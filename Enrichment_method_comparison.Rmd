---
title: "WGCNA analysis of PSC patients"
author: "William Wu"
date: "2024-08-07"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    code_folding: "hide"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background

We use the Weighted Gene Correlation Network Analysis (WGCNA) to analyse how the variables of our omics-data can be grouped together. The scaled (Z-score) and concatenated omics-data is analysed most thouroughly while each omics is analysed separately in a simpler way. Some chunks are commented out but left in the script to make it easier for someone who has done the Horvath tutorial to understand and modify this code. The graphical settings using the base-package graphics are unfortunately not optimized.

In summary the network model divides the variables into groups called modules based on the correlation between the variables. Thereafter, the module eigenvalues are related to clinical traits and the correlation values and p-values are calculated. For the most interesting module-trait pairs the gene significance (variable-trait correlation) and module membership (variable-module eigengene correlation) are calculated. Lastly all variables of the network model along with their gene significance and module membership are exported for further enrichment analysis.

**WGCNA Application to Proteomic and Metabolomic Data Analysis**

Originally WGCNA was developed only for gene expression. However, with proper missing data imputation and normalization, proteins and metabolites can be studied as well.

The correlation between variables is either positive or negative. In the signed analysis the negative correlation is not considered while the unsigned analysis calculates the absolute value of the correlation making positive and negative correlation equal. This article recommends to construct a signed network.

Article: <https://www.sciencedirect.com/science/article/pii/S0076687916302890>

**Horvath tutorial**

Down below is a short overview of the each step in the Horvath tutorial that can be accessed in the following link below. The most important functions are written down along with their most important arguments. For this analysis the steps 0, 1, 2.b, 3, and 5 are used in a modified way. The most interesting modules are exported.

Tutorial: <https://www.dropbox.com/scl/fo/4vqfiysan6rlurfo2pbnk/h?rlkey=thqg8wlpdn4spu3ihjuc1kmlu&e=1&dl=0>

Parameters:\
0. Filtering the omics-data for variables with low variance\
nearZeroVar() - freqCut =, uniqueCut =\
Comment: The function nearZeroVar() is used identically as in our mixOmics analysis

1.  Removing samples\
    cutreeStatic() - cutHeight = - Removes outliers\
    Comment: This step is solely used for initial visualization and not for removing outliers due to our low number of samples

2.a. Creating an automatic network\
blockwiseModules() - power = - Set soft threshold power with pickSoftThreshold()\
blockwiseModules() - TOMType = - Choose network type (unsigned or signed)\
blockwiseModules() - minModuleSize = - Choose minimal size of modules\
blockwiseModules() - deepSplit = - Choose sensitivity for cluster splitting (default = 2)\
Comment: This step was initially used but later abandoned in favor of the manual network

2.b. Creating a manual network\
pickSoftThreshold()\
adjacency() - Correlation matrix between all variables to the power of the soft threshold\
TOMsimilarity() - Transformation of the adjacency matrix to reduce noise and spurious associations\
hclust() - Create gene tree\
cutreeDynamic() - Create modules\
moduleEigengenes() - Calculate module eigengenes to create dendrogram\
mergeCloseModules() - Merge modules with similar expression profiles according to dendrogram\
Comment: This step is not optimized, i. e. the hyperparameters have not been iterated or motivated thouroughly

3.  Relating the modules with clinical traits\
    labeledHeatmap() - Choose which clinical traits to investigate for which modules (gene significance = variable-trait correlation; module membership = variable-module eigengene correlation)\
    Comment: This step is the most important one and is extended so that the most interesting module-trait pairs are exported into csv.files for further analysis

4.  Annotating with gene ontology\
    Subset interesting modules for annotation and enrichment analysis\
    Comment: This step is done in our enrichment_analysis script

5.  Visualizing the network model\
    Visualize gene network with heatmap and dendrogram\
    Visualize module network for a clinical variable with heatmap and dendrogram\
    Comment: This step is mainly important for visualising the entire network model

6.  Exporting the network model\
    Export gene network for visualization with external tools\
    Comment: This step is skipped since we are not using the external tools

## Read the libraries

## Read the libraries

```{r read_the_libraries, message=FALSE, warning=FALSE}
# Load essential libraries for data manipulation, WGCNA analysis, modeling, and parallel processing
library(tidyverse)     # For data manipulation and visualization
library(WGCNA)         # For weighted gene co-expression network analysis
library(caret)         # For preprocessing and feature selection
library(igraph)        # For network visualization and graph operations
library(doParallel)    # For enabling parallel computatio
library(multiGSEA)
```

```{r}
library(conflicted)    # Handles conflicts between functions from different packages

# Prefer using specific functions from selected packages in case of conflict
conflict_prefer("slice", "dplyr")
conflict_prefer("rename", "dplyr")
conflict_prefer("cor", "WGCNA")
```

```{r prallel}
# Initialize a parallel backend using 4 cores
cl <- makeCluster(4)  # Adjust number of cores depending on your system
registerDoParallel(cl)
```

## Set prequisites

```{r prequisites, message=FALSE, warning=FALSE}
# Ensure strings are not automatically converted to factors
options(stringsAsFactors = FALSE)

# Enable multithreading in WGCNA to speed up computations
enableWGCNAThreads()
```

## Load the data

The omics data comes in a uniform format with each row representing a patient/sample and each column representing a compound/feature/variable except the first column which contains the patient ID's. The metadata has been cleaned for the variables of interest so that they are represented by new binary columns. See the preprocessing script for details.

```{r load_data, message=FALSE, warning=FALSE}
# Load preprocessed datasets for each omic layer and the associated metadata
metabolites <- read_csv("../data/metabolite_preprocessed.csv")
proteins <- read_csv("../data/protein_preprocessed.csv")
miRNA <- read_csv("../data/miRNA_preprocessed.csv")
metadata <- read_csv("../data/metadata_preprocessed.csv")


medata_OlinkID <- read_csv("../data/metadata_OlinkID.csv")
medata_metabolites <- read_csv("medata_metabolites_kegg_filled.csv")
```

## Prepare the data

The patient ID column is set as the rownames to keep track of the rows.\
The metabolite data was probably not log2 transformed but only scaled with 1 as the median and all other values proportional.\
-\> The metabolite data needs to be log2 transformed The numerical columns of interest are selected in the metadata.

```{r format_data, message=FALSE, warning=FALSE}
# Keep first 33 patients and remove miRNAs with low variance
miRNA <- miRNA %>% 
  slice(1:33)
miRNA <- miRNA[,-nearZeroVar(miRNA, uniqueCut = 30)]  # Removes 1920 low-variance miRNAs

# Keep first 33 patients for proteins
proteins <- proteins %>% 
  slice(1:33)

# Log2-transform and filter metabolite data
metabolites <- metabolites %>% 
  log2() %>% 
  slice(1:33)
metabolites <- metabolites[,-nearZeroVar(metabolites, uniqueCut = 30)]  # Removes 29 low-variance metabolites

# Select only binary traits of interest from metadata
metadata <- metadata %>% 
  dplyr::select(cca_binary, ibd_binary, fibrosis_binary, alp_binary, bilirubin_binary) %>% 
  slice(1:33)




# Rename the binary traits for readability
formatted_names <- c("CCA", "IBD", "Fibrosis", "ALP", "Bilirubin")
```

We scale (Z-score) and concatenate the omics data.

```{r concatenate_data}
# Combine scaled miRNA, protein, and metabolite data into a single dataframe
multi_omics <- cbind(
  scale(miRNA[2:ncol(miRNA)]),        # Remove ID column and scale miRNA data
  scale(proteins[2:ncol(proteins)]),  # Remove ID column and scale protein data
  scale(metabolites[2:ncol(metabolites)]) # Remove ID column and scale metabolite data
) %>% 
  as.data.frame() %>% 
  select_if(~ n_distinct(.x) > 1)      # Remove columns with no variability

```

This function checks if there are any columns with too many missing values. Result: There are no such columns.

```{r check_missing_values}
# Check for missing values or genes/samples with too many NAs
# WGCNA recommends using this function before proceeding with analysis

gsg = goodSamplesGenes(multi_omics, verbose = 3)  # Check multi-omics data
gsg$allOK                                          # Should return TRUE if all data is suitable

gsg = goodSamplesGenes(miRNA[2:ncol(miRNA)], verbose = 3)  # Check miRNA data separately
gsg$allOK

gsg = goodSamplesGenes(proteins[2:ncol(proteins)], verbose = 3)  # Check protein data separately
gsg$allOK

gsg = goodSamplesGenes(metabolites[2:ncol(metabolites)], verbose = 3)  # Check metabolite data separately
gsg$allOK

```

# Multi-omics {.tabset}

## 1. Data input

This initial plot groups the samples with hierarchical clustering to check for outliers.

```{r multi_omics_visualise_samples}

# Perform hierarchical clustering on the combined multi-omics dataset
sampleTree = hclust(dist(multi_omics), method = "average")  # Use average linkage for clustering

# Create a dendrogram plot of the sample tree and save as a PDF
pdf(file = "../results/WGCNA/hclust.pdf", width = 12, height = 9)  # Adjust dimensions as needed
par(cex = 0.6)                    # Set character expansion for labels
par(mar = c(2, 8, 2, 0))          # Set plot margins

# Plot the dendrogram to visualize sample clustering
plot(sampleTree, 
     main = "Sample clustering to detect outliers", 
     sub = "", xlab = "", 
     cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)

# Optionally add a red horizontal line to help identify outliers
abline(h = 75, col = "red")
```

```{r multi_omics_filter_data}
##**Skipped**: This function divides the data into the clusters that can be seen in the plot above. Then only the main cluster ##is kept and the data is referred to as fmulti_omics. Any variables that are constant in the filtered dataset are removed.
# # Determine cluster under the line
# clust = cutreeStatic(sampleTree, cutHeight = 75, minSize = 10)
# table(clust)
# # clust 1 contains the samples we want to keep.
# keepSamples = (clust==1)
# fmulti_omics = multi_omics[keepSamples, ]
# 
# # Remove the constant variables in our filtered dataset
# fmulti_omics <- fmulti_omics %>% 
#     select_if(~ n_distinct(.x) > 1)
# 
# nGenes = ncol(fmulti_omics)
# nSamples = nrow(fmulti_omics)
```

```{r multi_omics_filter_metadata}
##**Skipped**: The metadata need to be matched to the main cluster that was kept and it is referred to as fmetadata.
# # Form a data frame analogous to expression data that will hold the clinical traits.
# Samples = rownames(fmulti_omics);
# traitRows = match(Samples, metadata$patient_id);
# fmetadata = metadata[traitRows, ];
# fmetadata <- fmetadata %>% column_to_rownames(var = "patient_id")
# collectGarbage();
```

The heatmap below show the hierarchical clustering of the samples with corresponding metadata where white means low, red means high, and grey means missing entry.

```{r multi_omics_visualise_traits}
# Convert binary clinical traits to color-coded matrix for visualization
# White = low (0), Red = high (1), Grey = missing
traitColors = numbers2colors(metadata, signed = FALSE)

# Save dendrogram + trait heatmap to PDF
pdf(file = "../results/WGCNA/sampleClustering_correlation_groups.pdf", width = 12, height = 9)
plotDendroAndColors(sampleTree, traitColors,
                    groupLabels = formatted_names, 
                    main = "Sample dendrogram and trait heatmap")
```

Intrestingly the Early and NoIBD groups are clustered together.

## 2.a Automatic network construction

We set an interval of soft thresholding powers and plot the scale independence and mean connectivity as a function of those powers. The scale independence reaches the plateau around power = 4.

```{r multi_omics_automatic_choose_power}
# Re-initialize parallel backend (ensure it's running)
cl <- makeCluster(4)  # Adapt number of cores to your machine
registerDoParallel(cl)

# Define a range of candidate powers for soft-thresholding
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Analyze scale-free topology fit and connectivity at each power
sft = pickSoftThreshold(multi_omics, powerVector = powers, verbose = 5)

# Save the soft-threshold analysis plots to PDF
pdf(file = "../results/WGCNA/Automatic_soft_threshold_analysis.pdf", width = 12, height = 9)
par(mfrow = c(1, 2))  # Plot two graphs side by side
cex1 = 0.9

# Plot scale-free topology fit index
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     xlab = "Soft Threshold (power)", 
     ylab = "Scale Free Topology Model Fit, signed R²", 
     type = "n", main = "Scale independence")
text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     labels = powers, cex = cex1, col = "red")
# Optional threshold line for R² (e.g. 0.90)
# abline(h = 0.90, col = "red")

# Plot mean connectivity for each power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)", 
     ylab = "Mean Connectivity", 
     type = "n", main = "Mean connectivity")
text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels = powers, cex = cex1, col = "red")
```

We create a network with our variables divided into 16 modules with outliers in module 0.

```{r multi_omics_automatic_create_network}
# Construct network and detect modules (unsupervised WGCNA)
net = blockwiseModules(multi_omics, power = 4,
                       TOMType = "unsigned", 
                       minModuleSize = 30,               # Minimum size of each module
                       reassignThreshold = 0, 
                       mergeCutHeight = 0.25,            # Merge threshold for similar modules
                       numericLabels = TRUE, 
                       pamRespectsDendro = FALSE, 
                       saveTOMs = TRUE,                  # Save TOM matrices for future use
                       saveTOMFileBase = "multi_omicsTOM",
                       verbose = 3)

# Show the distribution of module sizes (by label)
table(net$colors)
```

We create the dendrogram for our network.

```{r multi_omics__automatic_network_dendrogram}
# Set graphic window dimensions
sizeGrWindow(12, 9)

# Convert module numeric labels to color names
mergedColors = labels2colors(net$colors)

# Plot the gene dendrogram and color-coded module assignments
pdf(file = "../results/WGCNA/automatic_cluster_dendogram.pdf", width = 12, height = 9)
plotDendroAndColors(net$dendrograms[[1]], 
                    mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```

We save some of the results from our network for further analysis. These include the module distribution, its colors, the module eigenvalues, and the dendrogram.

```{r multi_omics_automatic_save_network}
# Extract module assignments, color codes, and eigengenes
moduleLabels = net$colors                       # Numeric module labels
moduleColors = labels2colors(net$colors)        # Corresponding color labels
MEs = net$MEs                                    # Module eigengenes (summary expression profiles)
geneTree = net$dendrograms[[1]]                 # Dendrogram of all features  
```

## 2.b Manual network construction

We set an interval of soft thresholding powers and plot the scale independence and mean connectivity as a function of those powers. The scale independence reaches the plateau around power = 7.

```{r multi_omics_manual_choose_power}
# Choose a refined set of candidate soft-thresholding powers
powers = c(c(1:5), seq(from = 5, to = 10, by = 1))

# Run network topology analysis to identify optimal power
sft = pickSoftThreshold(multi_omics, powerVector = powers, verbose = 5)

# Plot scale independence and connectivity
pdf(file = "../results/WGCNA/Manual_soft_threshold_analysis.pdf", width = 12, height = 9)
par(mfrow = c(1,2))
cex1 = 0.9

# Plot scale-free topology model fit
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
     xlab = "Soft Threshold (power)", ylab = "Scale Free Topology Fit, signed R²", 
     type = "n", main = "Scale independence")
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3]) * sft$fitIndices[,2], 
     labels = powers, cex = cex1, col = "red")

# Plot mean connectivity
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab = "Soft Threshold (power)", ylab = "Mean Connectivity", 
     type = "n", main = "Mean connectivity")
text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels = powers, cex = cex1, col = "red")

# Manually set the soft-threshold power for adjacency calculation
softPower = 7
```

We calculate the correlation between each variable in a pair-wise manner.

```{r multi_omics_manal_adjacency}
# Compute the adjacency matrix with the chosen power
adjacency = adjacency(multi_omics, power = softPower)

# Compute topological overlap matrix (TOM) and dissimilarity
TOM = TOMsimilarity(adjacency)
dissTOM = 1 - TOM

```

We visualize the dendrogram.

```{r multi_omics_manual_variables_dendrogram}
# Hierarchical clustering on TOM-based dissimilarity
geneTree = hclust(as.dist(dissTOM), method = "average")

# Plot the gene dendrogram
pdf(file = "../results/WGCNA/manual_soft_threshold_analysis.pdf", width = 12, height = 9)
plot(geneTree, xlab = "", sub = "", main = "Variable clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
```

We create 11 modules with the 0th module representing outliers.

```{r multi_omics_manual_modules}
# Identify modules using dynamic tree cut
minModuleSize = 30
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize)
table(dynamicMods)
```

We visualize the dendrogram again, this time with the corresponding module colors below.

```{r multi_omics_manual_modules_dendrogram}
# Assign module colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

# Visualize modules on the dendrogram
pdf(file = "../results/WGCNA/manual_cluster_dendogram_man_14.pdf", width = 12, height = 9)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Variable dendrogram and module colors")
```

We visualize the clustering of the module eigengenes.

```{r multi_omics_manual_eigengenes_network}
# Calculate module eigengenes and their dissimilarity
MEList = moduleEigengenes(multi_omics, colors = dynamicColors)
MEs = MEList$eigengenes
MEDiss = 1 - cor(MEs)
METree = hclust(as.dist(MEDiss), method = "average")

# Plot clustering of module eigengenes
pdf(file = "../results/WGCNA/module_merging.pdf", width = 12, height = 9)
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
abline(h = 0.15, col = "red")  # Optional: show merge threshold

MEDissThres = 0.15
merge = mergeCloseModules(multi_omics, dynamicColors, cutHeight = MEDissThres, verbose = 3)
mergedColors = merge$colors
mergedMEs = merge$newMEs
```

We are not merging any modules and therefore set the cutting line (MEDissThres) below the lowerst branches in the chunk above.

We visualize the cut tree with original and merged modules - No changes since we did not merge any modules.

```{r multi_omics_manual_network_dendrogram}
# Plot comparison of original and merged modules
pdf(file = "../results/WGCNA/modules_merged_dendogram.pdf", width = 12, height = 9)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```

We skip this step since the variables have already been set.

```{r save_modules}
### Rename to moduleColors
moduleColors = mergedColors
### Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
### Save module colors and labels for use in subsequent parts
save(MEs, moduleLabels, moduleColors, geneTree, file = "../results/WGCNA/modules_info.csv")
```

```{r}
# Correlate each variable with each module eigengene
MMandPvalue = corAndPvalue(multi_omics, MEs, use = "p")
MM = MMandPvalue$cor
pval = MMandPvalue$p

# Save module membership with p-values
moduleMembershipDF = data.frame(
  Variable    = colnames(multi_omics),
  ModuleColor = moduleColors,
  MM,
  pval
)
write.csv(moduleMembershipDF, file = "../results/WGCNA/module_membership_pvalues.csv", row.names = FALSE)
```

## 3. Relating modules to traits

We calculate the ME values for the modules and subsequently calculate the correlation and p-value in regards to the metadata.

```{r multi_omics_calculate_module_eigengenes}
moduleColors = mergedColors

# Number of variables (genes/features) and number of samples
nGenes = ncol(multi_omics)
nSamples = nrow(multi_omics)

# Retrieve precomputed module eigengenes
MEs = mergedMEs

# Compute Pearson correlations between module eigengenes and traits
moduleTraitCor = cor(MEs, metadata, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
```

We create a heatmap of the correlation and p-values that were calculated above. Here we can see which modules are significant for which trait.

```{r multi_omics_plot_modules_traits}
# Format correlation and p-value matrix as a labeled text matrix
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

# Generate and export the heatmap as PDF
pdf(file = "../results/WGCNA/manual_module_trait_pearson_heatmap.pdf", wi = 9, he = 6)
par(mar = c(5, 10, 4, 4))  # bottom, left, top, right
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = formatted_names,
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = "Module-trait relationships (Pearson)")
```

**Manual network interesting module-trait pairs** From this figure I identify the following pairs to be of interest (p \< 0,001):\
fibrosis: brown, green\
fibrosis_binary: brown, green\
alp: brown\
alp_binary: brown, green\
bilirubin: purple, red, brown\
bilirubin_binary: purple, brown, green

In the following sections we calculate the module mebership and gene significance for the inteeresting module-trait pairs and then export his information into csv files.

## 4. Focus on each trait

## Scatterplot of module membership (MM) vs gene significance (GS)

```{r}
scatter_MM_GS <- function(module, traitCol, topN = 10, color) {
  
  # --- Quick checks ---
  stopifnot(traitCol %in% colnames(metadata))
  stopifnot(module %in% moduleColors)

  # --- Format trait as dataframe ---
  traitDF <- data.frame(metadata[[traitCol]])
  names(traitDF) <- traitCol

  # --- Compute MM and GS correlations ---
  modNames <- substring(names(MEs), 3)
  geneMM   <- as.data.frame(cor(multi_omics, MEs, use = "p"))
  geneGS   <- as.data.frame(cor(multi_omics, traitDF, use = "p"))

  # --- Subset for variables in selected module ---
  colIdx <- match(module, modNames)
  moduleGenes <- moduleColors == module

  MMabs <- abs(geneMM[moduleGenes, colIdx])
  GSabs <- abs(geneGS[moduleGenes, 1])
  varNames <- names(multi_omics)[moduleGenes]

  # --- Rank top variables by MM × GS score ---
  score <- MMabs * GSabs
  topIdx <- order(score, decreasing = TRUE)[1:min(topN, length(score))]

  # --- Plot scatterplot ---
  verboseScatterplot(
    x = MMabs, y = GSabs,
    xlab = paste("Module Membership in", module, "module"),
    ylab = paste("Gene significance for", traitCol),
    main = "Module membership vs. gene significance",
    col = color,
    pch = 16, cex = 0.6,
    cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2
  )

  # Optional: annotate topN points (currently commented out)
  # text(MMabs[topIdx], GSabs[topIdx] + 0.02,
  #      labels = varNames[topIdx], pos = 3, cex = 0.5, col = "black")
}
```

```{r}
## Function to compute and visualize module activity scores by phenotype group
multiomics_score <- function(module_color = "yellow",
                             phenotype = "CCA",
                             module_df = moduleMembershipDF,
                             omics_df = multi_omics,
                             meta_df = metadata,
                             do_plot = TRUE) {

  # --- 1. Select variables in target module ---
  vars <- module_df %>%
    dplyr::filter(ModuleColor == module_color) %>%
    dplyr::pull(Variable)

  if (length(vars) == 0)
    stop("No variables found for module ‘", module_color, "’.")

  omics_filt <- omics_df %>% dplyr::select(dplyr::all_of(vars))

  # --- 2. Create binary trait indicator (case vs control) ---
  pheno_bin_col <- paste0(tolower(phenotype), "_binary")
  if (!pheno_bin_col %in% names(meta_df))
    stop("Column ‘", pheno_bin_col, "’ is missing in metadata.")

  is_case <- meta_df[[pheno_bin_col]] == 1
  omics_case <- omics_filt[is_case, , drop = FALSE]
  omics_control <- omics_filt[!is_case, , drop = FALSE]

  # --- 3. Combine with group labels ---
  df_all <- dplyr::bind_rows(
    as.data.frame(omics_case)    %>% dplyr::mutate(group = phenotype),
    as.data.frame(omics_control) %>% dplyr::mutate(group = paste0("No_", phenotype))
  )

  # --- 4. Z-score normalization (per variable) ---
  df_scaled <- df_all %>%
    dplyr::mutate(dplyr::across(where(is.numeric), ~ scale(.)[, 1]))

  # --- 5. Compute average module score per sample ---
  df_scores <- df_scaled %>%
    dplyr::rowwise() %>%
    dplyr::mutate(score = mean(dplyr::c_across(where(is.numeric)), na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::select(group, score)

  # --- 6. Sample counts and label positioning ---
  df_n <- df_scores %>%
    dplyr::group_by(group) %>%
    dplyr::summarise(n = dplyr::n(),
                     y_pos = max(score, na.rm = TRUE) + 0.05,
                     .groups = "drop")

  # --- 7. Statistical tests ---
  wilcox_res <- stats::wilcox.test(score ~ group, data = df_scores, exact = FALSE)
  cliff_res  <- effsize::cliff.delta(score ~ group, data = df_scores)
  pval <- formatC(wilcox_res$p.value, digits = 3, format = "g")

  # --- 8. Optional boxplot visualization ---
  if (isTRUE(do_plot)) {
    suppressMessages({
      p <- ggplot2::ggplot(df_scores, ggplot2::aes(group, score, fill = group)) +
        ggplot2::stat_boxplot(geom = "errorbar", width = .25) +
        ggplot2::geom_boxplot(width = 0.6, outlier.shape = NA) +
        ggplot2::geom_jitter(width = .1, size = 2, alpha = .6) +
        ggplot2::geom_text(data = df_n,
                           ggplot2::aes(x = group, y = y_pos,
                                        label = paste0("n = ", n)),
                           vjust = 0, fontface = "bold", size = 4) +
        ggplot2::expand_limits(y = max(df_n$y_pos) + 0.1) +
        ggplot2::theme_bw() +
        ggplot2::theme(panel.grid = ggplot2::element_blank(),
                       aspect.ratio = 2,
                       legend.position = "none",
                       plot.title = ggplot2::element_text(hjust = 0.5)) +
        ggplot2::labs(x = "", y = "Average z-score (module activity)",
                      title = paste0(phenotype, " - Wilcoxon test (", module_color, "), p = ", pval))
      print(p)
    })
  }

  # --- 9. Return score and test results ---
  list(scores = df_scores,
       wilcox = wilcox_res,
       cliff  = cliff_res)
}
```

### Fibrosis

```{r}
# Visualize MM vs GS for brown and green modules (Fibrosis)
pdf(file = "../results/WGCNA/fibrosis_module_membership.pdf", wi = 9, he = 6)
scatter_MM_GS("brown", "fibrosis_binary", color = "brown")
scatter_MM_GS("green", "fibrosis_binary", color = "forestgreen")
```

```{r}
# Compare module scores between fibrosis and non-fibrosis groups
pdf(file = "../results/WGCNA/fibrosis_modules_boxplot.pdf", wi = 9, he = 6)
multiomics_score("brown", "Fibrosis", moduleMembershipDF, multi_omics, metadata)
multiomics_score("green", "Fibrosis", moduleMembershipDF, multi_omics, metadata)
```

### ALP

```{r}
pdf(file = "../results/WGCNA/alp_module_membership.pdf", wi = 9, he = 6)
scatter_MM_GS("brown", "alp_binary", color = "brown")
scatter_MM_GS("green", "alp_binary", color = "forestgreen")
```

```{r}
pdf(file = "../results/WGCNA/alp_modules_boxplot.pdf", wi = 9, he = 6)
multiomics_score("brown", "ALP", moduleMembershipDF, multi_omics, metadata)
multiomics_score("green", "ALP", moduleMembershipDF, multi_omics, metadata)
```

### Bilirubin

```{r}
pdf(file = "../results/WGCNA/bilirubin_module_membership.pdf", wi = 9, he = 6)
scatter_MM_GS("brown", "bilirubin_binary", color = "brown")
scatter_MM_GS("green", "bilirubin_binary", color = "forestgreen")
```

```{r}
pdf(file = "../results/WGCNA/bilirubin_modules_boxplot.pdf", wi = 9, he = 6)
multiomics_score("brown", "Bilirubin", moduleMembershipDF, multi_omics, metadata)
multiomics_score("green", "Bilirubin", moduleMembershipDF, multi_omics, metadata)
```

### CCA

```{r}
pdf(file = "../results/WGCNA/CCA_module_membership.pdf", wi = 9, he = 6)
scatter_MM_GS("yellow", "cca_binary", color = "gold")
```

```{r}
pdf(file = "../results/WGCNA/CCA_modules_boxplot.pdf", wi = 9, he = 6)
multiomics_score("yellow", "CCA", moduleMembershipDF, multi_omics, metadata)
```

### IBD

```{r}
pdf(file = "../results/WGCNA/IBD_module_membership.pdf", wi = 9, he = 6)
scatter_MM_GS("yellow", "ibd_binary", color = "gold")
scatter_MM_GS("brown", "ibd_binary", color = "brown")

```

```{r}
pdf(file = "../results/WGCNA/IBD_modules_boxplot.pdf", wi = 9, he = 6)
multiomics_score("yellow", "IBD", moduleMembershipDF, multi_omics, metadata)
multiomics_score("brown", "IBD", moduleMembershipDF, multi_omics, metadata)
```

## 5. Global visualisation

We create a heatmap that shows the correlation between all of our variables. The bright spots are our modules.

```{r multi_omics_plot_variable_dendrogram_heatmap}
# Recompute the TOM matrix
dissTOM = 1 - TOMsimilarityFromExpr(multi_omics, power = 7)
plotTOM = dissTOM^7
diag(plotTOM) = NA  # Remove diagonal for clarity

pdf(file = "../results/WGCNA/WGCNA_tomplot.pdf", wi = 9, he = 6)
TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap and dendrogram")
```

```{r}
# Prepare trait names and compute correlations with modules
traitNames <- c("cca_binary", "ibd_binary", "alp_binary", "fibrosis_binary", "bilirubin_binary")
stopifnot(all(rownames(mergedMEs) == rownames(metadata)))
traits <- metadata[, traitNames, drop = FALSE]
MET <- orderMEs(cbind(mergedMEs, traits))

# Compute distance matrix (1 - |cor|) and cluster
dissME <- 1 - abs(cor(MET, use = "p"))
tree <- hclust(as.dist(dissME), method = "average")

# Rename trait labels for readability
labels_raw <- colnames(MET)
labels_custom <- sapply(labels_raw, function(name) {
  if (grepl("^ME", name)) return(name)
  name <- gsub("_binary", "", name)
  switch(name,
         alp = "ALP",
         cca = "CCA",
         ibd = "IBD",
         fibrosis = "Fibrosis",
         bilirubin = "Bilirubin",
         name)
})
tree$labels <- labels_custom

# Plot dendrogram of eigengenes and traits
pdf(file = "../results/WGCNA/WGCNA_tomplot.pdf", wi = 9, he = 6)
plot(tree,
     main = "Dendrogram of module eigengenes and traits\n(distance = 1 - |cor|)",
     xlab = "", sub = "", hang = 0.03, cex = 1)
dev.off()
```

```{r}
# Compute signed correlation matrix and rename dimensions
corMAT <- cor(MET, use = "p")
prettyNames <- c("CCA", "IBD", "ALP", "Fibrosis", "Bilirubin")
names(prettyNames) <- traitNames

renameFun <- function(x) ifelse(x %in% traitNames, prettyNames[x], x)
rownames(corMAT) <- renameFun(rownames(corMAT))
colnames(corMAT) <- renameFun(colnames(corMAT))

# Order rows/columns by hierarchical clustering
tree <- hclust(as.dist(1 - abs(corMAT)), method = "average")
ord <- tree$order
corMAT <- corMAT[ord, ord]

# Format text for cell labels
textMatrix <- signif(corMAT, 2)
dim(textMatrix) <- dim(corMAT)


pdf(file = "../results/WGCNA/Heatmap_moduleXtrait.pdf", wi = 9, he = 6)
par(mar = c(8, 8, 4, 4))  # bottom, left, top, right

labeledHeatmap(
  Matrix = corMAT,
  xLabels = colnames(corMAT),
  yLabels = rownames(corMAT),
  ySymbols = rownames(corMAT),
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  cex.text = 0.55,
  cex.lab = 1,
  xLabelsAngle = 90,
  setStdMargins = FALSE,
  zlim = c(-1, 1),
  main = "Signed correlation heatmap – modules & traits"
)
dev.off()
```

## 6. Enrichment

### Global function



```{r}
library(dplyr); library(stringr); library(tibble)
library(multiMiR); library(graphite); library(multiGSEA)

calc_diff_log <- function(mat, group) {
  cca_idx <- group == "CCA"
  tibble(
    feature = colnames(mat),
    logFC   = colMeans(mat[cca_idx , ], na.rm = TRUE) -
              colMeans(mat[!cca_idx, ], na.rm = TRUE),
    pval    = apply(mat, 2, function(x) t.test(x ~ group)$p.value)
  )
}



dedup_minp <- function(df) {
  df %>% arrange(pval) %>% distinct(feature, .keep_all = TRUE)
}



clean_empty <- function(df) {
  df %>% filter(!is.na(feature), feature != "")
}



rank_vec <- function(df) {
  score <- sign(df$logFC) * -log10(df$pval)
  keep  <- is.finite(score) & !duplicated(df$feature)
  setNames(score[keep], df$feature[keep])
}


group_vec <- ifelse(metadata$cca_binary == 1, "CCA", "nonCCA")
group_fac <- factor(group_vec, levels = c("nonCCA", "CCA"))


### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(multi_omics), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(multi_omics), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(multi_omics), value = TRUE)

### Statistiques brutes
gene_stats  <- calc_diff_log(multi_omics[, gene_cols ],  group_fac)
prot_stats  <- calc_diff_log(multi_omics[, prot_cols ],  group_fac)
met_stats   <- calc_diff_log(multi_omics[, met_cols ],   group_fac)

### --- 1B  Protéines : OID → UniProt et split “A,B” ----------------------
oid_map <- medata_OlinkID %>%
  filter(OlinkID == "Uniprot ID") %>%
  pivot_longer(-OlinkID, names_to = "oid", values_to = "uniprot") %>%
  filter(uniprot != "")

prot_stats <- prot_stats %>%
  left_join(oid_map, by = c("feature" = "oid")) %>%
  mutate(feature = coalesce(uniprot, feature)) %>%   # garde UniProt s’il existe
  select(feature, logFC, pval) %>%
  mutate(feature = str_remove_all(feature, "\\s+")) %>%  # retire espaces
  separate_rows(feature, sep = ",")                       # ← Éclate “A,B”

### --- Métabolites : COMP ID → HMDB (sinon KEGG)
met_map <- medata_metabolites %>%
  select(`COMP ID`, HMDB, KEGG) %>%
  mutate(cid_char = as.character(`COMP ID`),
         id_final = if_else(HMDB != "" & !is.na(HMDB), HMDB, KEGG)) %>%
  filter(id_final != "") %>%
  select(cid_char, id_final)

met_stats <- met_stats %>%
  left_join(met_map, by = c("feature" = "cid_char")) %>%
  mutate(feature = coalesce(id_final, feature),
         feature = str_remove_all(feature, "\\s+")) %>%
  separate_rows(feature, sep = ",") %>%
  select(feature, logFC, pval)




### 1D  map gènes cibles (miRTarBase uniquement)
mir_pat <- regex("^hsa[-_](mir|miR|let)", ignore_case = TRUE)
mir_vec <- unique(gene_stats$feature[str_detect(gene_stats$feature, mir_pat)])

mm <- get_multimir(mirna = mir_vec, table = "validated",
                   org = "hsa", summary = FALSE)

targets <- mm@data %>%
  filter(database == "mirtarbase") %>%
  select(mirna = mature_mirna_id, target_symbol) %>% distinct()
```

```{r}
run_multiGSEA <- function(multi_omics, metadata,
                          moduleMembershipDF,
                          condition_bin,          # nom de la colonne binaire
                          module_color,           # ex. "yellow"
                          oid_map, met_map, targets,
                          dbs = c("kegg", "reactome")) {

  ## ─── 0. petits helpers ───────────────────────────────────────────────
  calc_diff_log <- function(mat, group) {
    pos <- group == "POS"
    tibble(
      feature = colnames(mat),
      logFC   = colMeans(mat[pos , ], na.rm = TRUE) -
                colMeans(mat[!pos, ], na.rm = TRUE),
      pval    = apply(mat, 2, function(x) t.test(x ~ group)$p.value)
    )
  }
  dedup_minp <- function(df) df %>% arrange(pval) %>% distinct(feature,.keep_all=TRUE)
  clean_empty<- function(df) df %>% filter(!is.na(feature), feature != "")
  rank_vec   <- function(df) {
      s <- sign(df$logFC)*-log10(df$pval)
      setNames(s[is.finite(s) & !duplicated(df$feature)], df$feature[is.finite(s)&!duplicated(df$feature)])
  }

  ## ─── 1. groupe POS / NEG ────────────────────────────────────────────
  group_fac <- factor(ifelse(metadata[[condition_bin]] == 1, "POS", "NEG"),
                      levels = c("NEG", "POS"))

  ## ─── 2. stats brutes et mapping ID ──────────────────────────────────
  gene_cols <- grep("^hsa[-_]",  colnames(multi_omics), value = TRUE, ignore.case = TRUE)
  prot_cols <- grep("^OID",     colnames(multi_omics), value = TRUE)
  met_cols  <- grep("^(X)?[0-9]+$", colnames(multi_omics), value = TRUE)

  gene_stats <- calc_diff_log(multi_omics[, gene_cols], group_fac)
  prot_stats <- calc_diff_log(multi_omics[, prot_cols], group_fac)
  met_stats  <- calc_diff_log(multi_omics[, met_cols ], group_fac)

  ## protéines
  prot_stats <- prot_stats %>%
      left_join(oid_map, by = c("feature" = "oid")) %>%
      mutate(feature = coalesce(uniprot, feature)) %>%
      select(feature, logFC, pval) %>%
      mutate(feature = str_remove_all(feature, "\\s+")) %>%
      separate_rows(feature, sep = ",")

  ## métabolites
  met_stats <- met_stats %>%
      left_join(met_map, by = c("feature" = "cid_char")) %>%
      mutate(feature = coalesce(id_final, feature),
             feature = str_remove_all(feature, "\\s+")) %>%
      separate_rows(feature, sep = ",") %>%
      select(feature, logFC, pval)

  ## miRNA → gènes
  mir_pat <- regex("^hsa[-_](mir|miR|let)", ignore_case = TRUE)
  mir_vec <- unique(gene_stats$feature[str_detect(gene_stats$feature, mir_pat)])

  mir_rows  <- gene_stats %>% filter(str_detect(feature, mir_pat))
  gene_keep <- gene_stats %>% filter(!str_detect(feature, mir_pat))

  mir_prop <- mir_rows %>%
      rename(mirna = feature) %>%
      inner_join(targets, by = c("mirna")) %>%
      mutate(feature = target_symbol, logFC = -logFC) %>%
      select(feature, logFC, pval) %>%
      group_by(feature) %>%
      summarise(logFC = mean(logFC), pval = min(pval), .groups = "drop")

  gene_stats <- bind_rows(gene_keep, mir_prop)

  ## nettoyer / dé-doublonner
  gene_stats <- gene_stats %>% clean_empty() %>% dedup_minp()
  prot_stats <- prot_stats %>% clean_empty() %>% dedup_minp()
  met_stats  <- met_stats  %>% clean_empty() %>% dedup_minp()

  ranks_gene <- rank_vec(gene_stats)
  ranks_prot <- rank_vec(prot_stats)
  ranks_met  <- rank_vec(met_stats)

  omics_ranked <- list(transcriptome = ranks_gene,
                       proteome      = ranks_prot,
                       metabolome    = ranks_met)

  ## ─── 3. définitions de voies & enrichissement ───────────────────────
  path_defs <<- getMultiOmicsFeatures(
      dbs   = dbs,
      layer = names(omics_ranked),
      returnTranscriptome = "SYMBOL",
      returnProteome      = "UNIPROT",
      returnMetabolome    = "HMDB",
      useLocal = FALSE)

  enrich_scores <<- multiGSEA(path_defs, omics_ranked, minSize = 5)


  df <- extractPvalues(enrich_scores, pathwayNames = names(path_defs[[1]])) %>%
        mutate(combined_pval  = combinePvalues(., method = "stouffer"),
               combined_padj  = p.adjust(combined_pval, method = "BH"),
               pathway = names(path_defs[[1]]))

  ## ─── 4. empreinte du module demandé ─────────────────────────────────
  yellow_features <- moduleMembershipDF %>%
      filter(ModuleColor == module_color) %>% pull(Variable)

  ## mapping identique à plus haut (résumé)
  prot_y <- tibble(orig = yellow_features) %>%
      filter(str_detect(orig, "^OID")) %>%
      left_join(oid_map, by = c("orig" = "oid")) %>%
      transmute(feature = uniprot) %>% filter(!is.na(feature), feature!="")

  met_y  <- tibble(orig = yellow_features) %>%
      filter(str_detect(orig, "^(X)?[0-9]+$")) %>%
      mutate(cid_char = str_remove(orig, "^X")) %>%
      left_join(met_map, by = "cid_char") %>%
      transmute(feature = id_final) %>% filter(!is.na(feature), feature!="")

  mir_y  <- tibble(orig = yellow_features) %>%
      filter(str_detect(orig, mir_pat)) %>%
      inner_join(targets, by = c("orig" = "mirna")) %>%
      transmute(feature = target_symbol)

  gene_y <- tibble(feature = yellow_features) %>%
      filter(!feature %in% c(prot_y$feature, met_y$feature, mir_y$feature),
             !str_detect(feature, "^OID"),
             !str_detect(feature, "^(X)?[0-9]+$"),
             !str_detect(feature, mir_pat))

  yellow_map <- list(
      transcriptome = unique(c(gene_y$feature, mir_y$feature)),
      proteome      = unique(prot_y$feature),
      metabolome    = unique(met_y$feature))
  
  
  mod_size <- sapply(yellow_map, length)      # vecteur named
  mod_size_total <- sum(mod_size)

  count_hits <- function(pw_list, hits)
      sapply(pw_list, function(m) sum(m %in% hits))
  
  


  hits_df <- tibble(
      pathway      = names(path_defs[[1]]),
      hit_gene     = count_hits(path_defs$transcriptome, yellow_map$transcriptome),
      hit_prot     = count_hits(path_defs$proteome,      yellow_map$proteome),
      hit_metab    = count_hits(path_defs$metabolome,    yellow_map$metabolome)
  ) %>%   mutate(
    pct_gene  = hit_gene  / mod_size["transcriptome"] * 100,
    pct_prot  = hit_prot  / mod_size["proteome"]      * 100,
    pct_metab = hit_metab / mod_size["metabolome"]    * 100,
    total_hits = hit_gene + hit_prot + hit_metab,
    pct_total  = total_hits / mod_size_total * 100
  )

  ## ─── 5. fusion & retour ─────────────────────────────────────────────
  res <- df %>% left_join(hits_df, by = "pathway") %>%
         arrange(combined_padj)

  return(res)
}





# ──────────────────────────────────────────────────────────────────────────
#  bar_enrichment_plot()
#      • res_tbl     : data-frame produced by the workflow (must contain
#                      pathway, combined_padj, pct_total columns)
#      • module_col  : colour / name of the WGCNA module (for the title)
#      • pheno_lab   : short label of the comparison (default "CCA")
#      • top_n       : how many pathways to draw (default 20)
#      • maxlen      : maximum visible chars per label (*excluding* star)
#      • palette     : any scico palette (default = "vik")
#  returns a ggplot object
# ──────────────────────────────────────────────────────────────────────────
bar_enrichment_plot <- function(res_tbl,
                                module_col = "Yellow",
                                pheno_lab  = "CCA",
                                top_n      = 20,
                                maxlen     = 50,
                                palette    = "vik") {

  library(dplyr); library(stringr); library(purrr)
  library(ggplot2); library(scico)

  plot_df <- res_tbl %>% 
    filter(!is.na(combined_padj)) %>% 
    arrange(combined_padj) %>% 
    slice_head(n = top_n) %>% 
    mutate(
      score    = -log10(combined_padj),
      pct_lab  = paste0(round(pct_total), "%"),

      db_star  = case_when(
        str_detect(pathway, "^\\(REACTOME\\)") ~ "*",
        str_detect(pathway, "^\\(KEGG\\)"    ) ~ "**",
        TRUE                                    ~ ""
      ),
      path_clean = str_remove(pathway, "^\\((KEGG|REACTOME)\\)\\s*"),

      trunc_w    = pmax(1, maxlen - nchar(db_star) - 1L),
      path_abbr  = map2_chr(path_clean, trunc_w,
                            ~ str_trunc(.x, width = .y, side = "right")),

      ## make labels unique AFTER truncation
      pathway_short = make.unique(paste0(path_abbr, " ", db_star), sep = " "),
      pathway_short = factor(pathway_short, levels = rev(pathway_short))
    )

  ggplot(plot_df,
         aes(x = score, y = pathway_short, fill = combined_padj)) +
    geom_col() +
    geom_text(aes(label = pct_lab, x = score + 0.15),
              hjust = 0, size = 3) +
    scale_fill_scico(
      palette   = palette,
      direction = 1,
      trans     = "reverse",
      name      = "adjusted p-value"
    ) +
    scale_x_continuous(expand = expansion(mult = c(0, 0.15))) +
    labs(
      x       = expression(-log[10]~"(adjusted p-value)"),
      y       = NULL,
      title   = sprintf("%s enrichment – %% of %s module",
                        pheno_lab, module_col),
      caption = "* Reactome      ** KEGG"
    ) +
    theme_minimal(base_size = 11) +
    theme(
      panel.grid.major.y    = element_blank(),
      legend.position       = "right",
      plot.caption          = element_text(hjust = 0, vjust = 1, size = 9),
      plot.caption.position = "plot"
    )
}



# --------------------------- HELPERS HIERARCHIE ---------------------------

# Récupère la hiérarchie BRITE (niveau1; niveau2; …) d’un pathway KEGG
gget_kegg_brite_path <- function(pwy_id) {
  brite <- tryCatch(KEGGREST::keggGet(pwy_id)[[1]]$BRITE,
                    error = function(e) NA_character_)
  if (is.null(brite) || length(brite) == 0) return(NA_character_)
  brite <- brite[brite != ""]
  paste(brite, collapse = "; ")              # niv1; niv2; niv3 …
}

# Récupère la lignée (top-level → … → pathway) d’un Reactome ID
get_reactome_lineage <- function(pwy_id) {
  lineage <- AnnotationDbi::select(reactome.db, keys = pwy_id,
                                   columns = "PATHNAME")$PATHNAME
  if (length(lineage) == 0 || is.na(lineage)) return(NA_character_)
  strsplit(lineage, ";\\s*")[[1]]            # vecteur [lvl1, lvl2, …, leaf]
}

# Construit un data.tree pour une base (KEGG ou Reactome)
#   df  = tibble(pathway_id, lvl1, lvl2, lvl3, lvl4, db_src)
build_native_tree <- function(df, db_label) {
  root <- data.tree::Node$new(db_label)
  purrr::pwalk(df, function(pathway_id, lvl1, lvl2, lvl3, lvl4, db_src) {
    cur <- root
    for (lvl in c(lvl1, lvl2, lvl3, lvl4, pathway_id)) {
      if (!is.na(lvl) && lvl != "") {
        nxt <- cur$Get(lvl, filterFun = function(x) x$name == lvl)
        if (is.null(nxt)) nxt <- cur$AddChild(lvl)
        cur <- nxt
      }
    }
  })
  root
}

# --------------------- BARPLOT + DENDROGRAMME PRINCIPAL -------------------

plot_enrichment_with_tree <- function(res_tbl, path_defs, module_col = "Yellow",
                                      pheno_lab  = "CCA", top_n = 20, maxlen = 50,
                                      palette = "vik", hclust_method = "ward.D") {
  library(dplyr); library(stringr); library(purrr); library(tidyr)
  library(ggplot2); library(scico); library(data.tree); library(ggtree)
  library(KEGGREST); library(patchwork)

  # ----------------- 1. Sous‑ensemble des pathways à tracer ---------------
  plot_df <- res_tbl %>%
    filter(!is.na(combined_padj)) %>%
    arrange(combined_padj) %>%
    slice_head(n = top_n) %>%
    mutate(db  = ifelse(str_detect(pathway, "^\\(KEGG\\)"), "KEGG", "Reactome"),
           id  = str_remove(pathway, "^\\((KEGG|REACTOME)\\)\\s*"))

  # ----------------- 2. Hiérarchie native KEGG ---------------------------
  kegg_df <- plot_df %>% filter(db == "KEGG")
  if (nrow(kegg_df) > 0) {
    kegg_hier <- tibble(pathway_id = kegg_df$id,
                        full_path  = vapply(kegg_df$id, gget_kegg_brite_path,
                                            character(1))) %>%
      separate(full_path, into = c("lvl1","lvl2","lvl3","lvl4"),
               sep = ";\\s*", fill = "right", remove = FALSE) %>%
      mutate(db_src = "KEGG")
    kegg_tree <- build_native_tree(kegg_hier, "KEGG")
  } else {
    kegg_tree <- NULL
  }

  # ----------------- 3. Hiérarchie native Reactome -----------------------
  react_df <- plot_df %>% filter(db == "Reactome")
  if (nrow(react_df) > 0) {
    react_hier <- tibble(pathway_id = react_df$id,
                         lineage = lapply(react_df$id, get_reactome_lineage)) %>%
      mutate(lvl1 = purrr::map_chr(lineage, `[`, 1, .default = NA),
             lvl2 = purrr::map_chr(lineage, `[`, 2, .default = NA),
             lvl3 = purrr::map_chr(lineage, `[`, 3, .default = NA),
             lvl4 = purrr::map_chr(lineage, `[`, 4, .default = NA),
             db_src = "Reactome")
    react_tree <- build_native_tree(react_hier, "Reactome")
  } else {
    react_tree <- NULL
  }

  # ----------------- 4. Fusion des deux sous‑arbres ----------------------
  root <- data.tree::Node$new("ROOT")
  if (!is.null(kegg_tree)) root$AddChildNode(kegg_tree)
  if (!is.null(react_tree)) root$AddChildNode(react_tree)

  # ----------------- 5. Dendrogramme ggplot -----------------------------
  phylo_tree <- ape::as.phylo.Node(root)
  p_dend <- ggtree::ggtree(phylo_tree, layout = "rectangular") +
    ggtree::geom_tiplab(align = TRUE, linetype = "dotted", size = 0) +
    theme_void() + theme(plot.margin = margin(t = 0, r = 6, b = 0, l = 0))

  # Réordonner les feuilles comme dans plot_df
  leaves_order <- plot_df$id
  p_dend <- ggtree::rotate_tree(p_dend, leaves_order)

  # ----------------- 6. Bar‑plot existant -------------------------------
  p_bar <- bar_enrichment_plot(res_tbl, module_col, pheno_lab,
                               top_n, maxlen, palette) +
    theme(plot.margin = margin(t = 0, r = 0, b = 0, l = 0))

  # ----------------- 7. Assemblage --------------------------------------
  p_final <- p_dend | p_bar + patchwork::plot_layout(widths = c(2, 4))
  return(p_final)
}

```

### Fibrosis

```{r}
res_fibrosis_brown <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "fibrosis_binary",
                         module_color  = "brown",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)

pdf(file = "../results/WGCNA/enrich_fibrosis_brown.pdf", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_fibrosis_brown,
         module_col = "brown",
         pheno_lab  = "Fibrosis",
       )
dev.off()


res_fibrosis_green <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "fibrosis_binary",
                         module_color  = "green",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)

pdf(file = "../results/WGCNA/enrich_fibrosis_green.pdf", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_fibrosis_green,
         module_col = "green",
         pheno_lab  = "Fibrosis",
       )
dev.off()
```

### ALP

```{r}

res_alp_brown <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "alp_binary",
                         module_color  = "brown",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)

res_alp_green <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "alp_binary",
                         module_color  = "green",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)


```

```{r}
pdf(file = "../results/WGCNA/enrich_alp_green.pdf", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_alp_green,
         module_col = "green",
         pheno_lab  = "ALP",
       )
dev.off()

pdf(file = "../results/WGCNA/enrich_alp_brown.pdf", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_alp_brown,
         module_col = "brown",
         pheno_lab  = "ALP",
       )
dev.off()
```

### Bilirubin

```{r}
res_bilirubin_brown <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "bilirubin_binary",
                         module_color  = "brown",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)



res_bilirubin_green <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "bilirubin_binary",
                         module_color  = "green",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)



pdf(file = "../results/WGCNA/enrich_bilirubin_brown", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_bilirubin_brown,
         module_col = "brown",
         pheno_lab  = "Bilirubin",
       )
dev.off()

pdf(file = "../results/WGCNA/enrich_bilirubin_green.pdf", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_bilirubin_green,
         module_col = "green",
         pheno_lab  = "Bilirubin",
       )
dev.off()
```

### CCA

```{r}
res_cca <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "cca_binary",
                         module_color  = "yellow",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)


```

```{r}
#pdf(file = "../results/WGCNA/enrich_cca_yellow.pdf", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_cca,
         module_col = "yellow",
         pheno_lab  = "CCA",
       )
#dev.off()
```

### IBD

```{r}
res_ibd_yellow <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "ibd_binary",
                         module_color  = "yellow",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)


res_ibd_brown <- run_multiGSEA(multi_omics, metadata,
                         moduleMembershipDF,
                         condition_bin = "ibd_binary",
                         module_color  = "brown",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)




pdf(file = "../results/WGCNA/enrich_ibd_brown", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_ibd_yellow,
         module_col = "yellow",
         pheno_lab  = "IBD",
       )
dev.off()


pdf(file = "../results/WGCNA/enrich_ibd_brown", wi = 9, he = 6)
bar_enrichment_plot(
         res_tbl    = res_ibd_brown,
         module_col = "brown",
         pheno_lab  = "IBD",
       )
dev.off()
```

## 7. Test enrichment on results

```{r}
# Assurez-vous d’avoir ces paquets :
# install.packages(c("readr", "dplyr", "ggVennDiagram"))

library(readr)
library(dplyr)
library(ggVennDiagram)
library(ggplot2)

module_disease_analysis <- function(couleur, maladie) {
  
  # Étape 1 : fichier de la maladie
  maladie_file <- paste0("../results/mixOmics_", maladie, "_binary.csv")
  maladie_data <- read_csv(maladie_file, show_col_types = FALSE)
  compounds_list <- maladie_data$compounds
  
  # Étape 2 : variables du module couleur
  filtered_module <- moduleMembershipDF %>%
    filter(ModuleColor == couleur)
  variables_list <- rownames(filtered_module)
  
  # 3. Diagramme de Venn  ────────────────────────────────────────────────
  venn_plot <- ggVennDiagram(
    list(Compounds = compounds_list,
         Variables = variables_list),
    label = "count"
  ) +
    theme_void()
  
  print(venn_plot)
  
  # Étape 4 : fusion des listes puis filtrage
  merged_list <- union(compounds_list, variables_list)
  filtered_multiomics <- multi_omics[, intersect(colnames(multi_omics), merged_list)]
  
  return(filtered_multiomics)
}

# Exemple d’appel :
resultat <- module_disease_analysis("yellow", "cca")
```

```{r}
res_caca <- run_multiGSEA(resultat, metadata,
                         moduleMembershipDF,
                         condition_bin = "cca_binary",
                         module_color  = "yellow",
                         oid_map = oid_map,
                         met_map = met_map,
                         targets = targets)


```

```{r}
plot_enrichment_with_tree(res_fibrosis_brown, path_defs,  module_col = "Yellow", pheno_lab = "CCA")
```

### ICI MAPPPPPPP


```{r}
library(multiMiR)

calc_diff_log <- function(mat, group) {
  cca_idx <- group == "CCA"
  tibble(
    feature = colnames(mat),
    logFC   = colMeans(mat[cca_idx , ], na.rm = TRUE) -
              colMeans(mat[!cca_idx, ], na.rm = TRUE),
    pval    = apply(mat, 2, function(x) t.test(x ~ group)$p.value)
  )
}

clean_empty <- function(df) {
  df %>% filter(!is.na(feature), feature != "")
}



rank_vec <- function(df) {
  score <- sign(df$logFC) * -log10(df$pval)
  keep  <- is.finite(score) & !duplicated(df$feature)
  setNames(score[keep], df$feature[keep])
}


group_vec <- ifelse(metadata$cca_binary == 1, "CCA", "nonCCA")
group_fac <- factor(group_vec, levels = c("nonCCA", "CCA"))


### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(multi_omics), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(multi_omics), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(multi_omics), value = TRUE)

### Statistiques brutes
gene_stats  <- calc_diff_log(multi_omics[, gene_cols ],  group_fac)
prot_stats  <- calc_diff_log(multi_omics[, prot_cols ],  group_fac)
met_stats   <- calc_diff_log(multi_omics[, met_cols ],   group_fac)

oid_map <- medata_OlinkID %>%
  filter(OlinkID == "Uniprot ID") %>%
  pivot_longer(-OlinkID, names_to = "oid", values_to = "uniprot") %>%
  filter(uniprot != "")


met_map <- medata_metabolites %>%
  select(`COMP ID`, HMDB, KEGG) %>%
  mutate(cid_char = as.character(`COMP ID`),
         id_final = if_else(HMDB != "" & !is.na(HMDB), HMDB, KEGG)) %>%
  filter(id_final != "") %>%
  select(cid_char, id_final)



mir_interest <- gene_stats$feature      # hsa-let-7a-1, etc.

## ------------------------------------------------------------------
## 2. Interroger multiMiR (cibles validées uniquement) --------------
## ------------------------------------------------------------------
qry <- get_multimir(
           mirna   = mir_interest,
           org     = "hsa",
           table   = "validated",   # mirecords, miRTarBase, TarBase
           summary = FALSE           # regroupe les 3 bases
       )

mirna2gene <- qry@data %>% 
  filter(database == "mirtarbase") %>%
  select(mature_mirna_id, target_symbol) %>% 
  distinct()

```


```{r}
group_vec <- ifelse(metadata$cca_binary == 1, "CCA", "nonCCA")
group_fac <- factor(group_vec, levels = c("nonCCA", "CCA"))


### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(multi_omics), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(multi_omics), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(multi_omics), value = TRUE)

### Statistiques brutes
gene_stats  <- calc_diff_log(multi_omics[, gene_cols ],  group_fac)
prot_stats  <- calc_diff_log(multi_omics[, prot_cols ],  group_fac)
met_stats   <- calc_diff_log(multi_omics[, met_cols ],   group_fac)




prot_stats <- prot_stats %>%
  left_join(oid_map, by = c("feature" = "oid")) %>%
  mutate(feature = coalesce(uniprot, feature)) %>%   # garde UniProt s’il existe
  select(feature, logFC, pval) %>%
  mutate(feature = str_remove_all(feature, "\\s+")) %>%  # retire espaces
  separate_rows(feature, sep = ",")






met_stats <- met_stats %>%
  left_join(met_map, by = c("feature" = "cid_char")) %>%
  mutate(feature = coalesce(id_final, feature),
         feature = str_remove_all(feature, "\\s+")) %>%
  separate_rows(feature, sep = ",") %>%
  select(feature, logFC, pval)






### 1D  map gènes cibles (miRTarBase uniquement)
mir_pat <- regex("^hsa[-_](mir|miR|let)", ignore_case = TRUE)
mir_vec <- unique(gene_stats$feature[str_detect(gene_stats$feature, mir_pat)])

mm <- get_multimir(mirna = mir_vec, table = "validated",
                   org = "hsa", summary = FALSE)

targets <- mm@data %>%
  filter(database == "mirtarbase") %>%
  select(mirna = mature_mirna_id, target_symbol) %>% distinct()

mir_rows  <- gene_stats %>% filter(str_detect(feature, mir_pat))
gene_keep <- gene_stats %>% filter(!str_detect(feature, mir_pat))

mir_prop <- mir_rows %>%
      rename(mirna = feature) %>%
      inner_join(targets, by = c("mirna")) %>%
      mutate(feature = target_symbol, logFC = -logFC) %>%
      select(feature, logFC, pval) %>%
      group_by(feature) %>%
      summarise(logFC = mean(logFC), pval = min(pval), .groups = "drop")

gene_stats <- bind_rows(gene_keep, mir_prop)


```




### On y est presque (metabo)

```{r}
library(readr)   # read_delim, write_delim
library(dplyr)   # filter, across
medata_metabolites <- read_csv("../data/metadata_metabolomics.csv")
id_cols <- c("PUBCHEM", "CAS", "KEGG", "HMDB")

# ─── 3. Boucle pour filtrer et enregistrer ───────────────
for (id in id_cols) {
  subset <- medata_metabolites %>%
    filter(!is.na(.data[[id]]) & trimws(.data[[id]]) != "")

  out <- paste0("medata_metabolites_", tolower(id), ".csv")
  write_delim(subset, out, delim = ",")     # même séparateur que l'original
  message(out, " : ", nrow(subset), " lignes")
}


library(limma)
calc_diff_limma <- function(mat, group_fac) {
  # mat : échantillons × variables  (donc on transp. plus bas)
  design <- model.matrix(~ group_fac)        # 0 = non-CCA, 1 = CCA
  fit    <- lmFit(t(mat), design)            # chaque métabolite = un modèle linéaire
  fit    <- eBayes(fit)                      # shrinkage des variances
  tibble(
    feature = rownames(fit$coefficients),
    logFC   = fit$coefficients[, "group_facCCA"],
    pval    = fit$p.value    [, "group_facCCA"]
  )
}
```

```{r}
HMDB <- read_csv("HMDB_end.csv")

CAS <- read_csv("CAS_end.csv")

KEGG <- read_csv("KEGG_end.csv")

# Placer le fichier dans le dossier de travail ou indiquer le chemin complet
pubchem <- read.table(
  "pubchem_end.txt",
  sep = "\t",           # séparateur tabulation
  header = FALSE,       # pas d’en-tête dans le fichier
  col.names = c("CID", "InChIKey"),
  stringsAsFactors = FALSE,
  quote = "",           # protège les guillemets éventuels
  comment.char = ""     # évite que '#', ';'… soient vus comme commentaires
)
```

```{r}
library(tidyverse)

### 1.  Nettoyer / mettre en forme les tables de correspondance -------------
# -- KEGG -------------------------------------------------------------------
kegg_clean <- KEGG %>%                 # KEGG : 3 colonnes déjà propres
  filter(Score > 0)                    # supprimer Score == 0
# vecteur nom = ID, valeur = InChIKey
kegg_vec   <- deframe(kegg_clean %>% select(KEGG, InChIKey))

# -- HMDB -------------------------------------------------------------------
hmdb_clean <- HMDB %>%                             # 1 colonne composée
  separate(
    `Human Metabolome Database;InChIKey;Score`,
    into  = c("HMDB", "InChIKey", "Score"),
    sep   = ";",
    remove = TRUE
  ) %>%
  mutate(Score = as.numeric(Score)) %>%            # Score devient numérique
  filter(Score > 0)
hmdb_vec   <- deframe(hmdb_clean %>% select(HMDB, InChIKey))

# -- CAS --------------------------------------------------------------------
cas_clean  <- CAS %>%
  filter(Score > 0)
cas_vec    <- deframe(cas_clean %>% select(CAS, InChIKey))

# -- PubChem (pas de Score à filtrer) ---------------------------------------
pubchem_vec <- deframe(pubchem %>% select(CID, InChIKey))


### 2.  Ajouter la colonne InChIKey à medata_metabolites ---------------------
lookup_inchikey <- function(hmdb_ids, pubchem_ids, cas_ids, kegg_ids) {
  # hmdb_ids, … sont des chaînes (potentiellement NA) à spliter
  # 1) HMDB (séparateur ,)  2) PubChem (;)  3) CAS (;)  4) KEGG (,)
  # renvoie une liste(list(InChIKey, origine)) prête à être unnested
  
    # HMDB --------------------------------------------------------------------
  for (id in str_split(hmdb_ids %||% "", ",")[[1]]) {
    id <- str_trim(id)
    if (id != "" && !is.na(hmdb_vec[id])) {
      return(list(InChIKey = hmdb_vec[id], Source = "HMDB"))
    }
  }
  

  
      # KEGG --------------------------------------------------------------------
  for (id in str_split(kegg_ids %||% "", ",")[[1]]) {
    id <- str_trim(id)
    if (id != "" && !is.na(kegg_vec[id])) {
      return(list(InChIKey = kegg_vec[id], Source = "KEGG"))
    }
  }
  
     # PubChem -----------------------------------------------------------------
  for (id in str_split(pubchem_ids %||% "", ";")[[1]]) {
    id <- str_trim(id)
    if (id != "" && !is.na(pubchem_vec[id])) {
      return(list(InChIKey = pubchem_vec[id], Source = "PubChem"))
    }
  }

  
    # CAS ---------------------------------------------------------------------
  for (id in str_split(cas_ids %||% "", ";")[[1]]) {
    id <- str_trim(id)
    if (id != "" && !is.na(cas_vec[id])) {
      return(list(InChIKey = cas_vec[id], Source = "CAS"))
    }
  }
  

  # Si rien trouvé ----------------------------------------------------------
  list(InChIKey = NA_character_, Source = "Aucun")
}

medata_metabolites <- medata_metabolites %>%              # <- votre tibble
  rowwise() %>%
  mutate(tmp = list(lookup_inchikey(HMDB, PUBCHEM, CAS, KEGG))) %>%
  unnest_wider(tmp) %>%                                   # crée InChIKey + Source
  ungroup()

### 3.  Décompte des origines -----------------------------------------------
provenance_count <- medata_metabolites %>%
  count(Source, name = "n") %>%
  arrange(desc(n))

print(provenance_count)

```

```{r}
library(dplyr); library(stringr); library(tibble)
library(multiMiR); library(graphite); library(multiGSEA)

calc_diff_log <- function(mat, group) {
  cca_idx <- group == "CCA"
  tibble(
    feature = colnames(mat),
    logFC   = colMeans(mat[cca_idx , ], na.rm = TRUE) -
              colMeans(mat[!cca_idx, ], na.rm = TRUE),
    pval    = apply(mat, 2, function(x) t.test(x ~ group)$p.value)
  )
}



dedup_minp <- function(df) {
  df %>% arrange(pval) %>% distinct(feature, .keep_all = TRUE)
}



clean_empty <- function(df) {
  df %>% filter(!is.na(feature), feature != "")
}



rank_vec <- function(df) {
  score <- sign(df$logFC) * -log10(df$pval)
  keep  <- is.finite(score) & !duplicated(df$feature)
  setNames(score[keep], df$feature[keep])
}


group_vec <- ifelse(metadata$cca_binary == 1, "CCA", "nonCCA")
group_fac <- factor(group_vec, levels = c("nonCCA", "CCA"))


### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(multi_omics), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(multi_omics), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(multi_omics), value = TRUE)

### Statistiques brutes
gene_stats  <- calc_diff_limma(multi_omics[, gene_cols ],  group_fac)
prot_stats  <- calc_diff_limma(multi_omics[, prot_cols ],  group_fac)
met_stats <- calc_diff_limma(multi_omics[, met_cols ], group_fac)




```

```{r}
library(tidyverse)

### 1. Harmoniser les types --------------------------------------------------
met_stats <- met_stats %>% 
  mutate(feature = as.character(feature))      # feature devient <chr>

id2inchikey <- medata_metabolites %>% 
  mutate(`COMP ID` = as.character(`COMP ID`)) %>%   # COMP ID devient <chr>
  select(`COMP ID`, InChIKey) %>% 
  distinct()

### 2. Jointure --------------------------------------------------------------
met_stats <- met_stats %>% 
  left_join(id2inchikey, by = c("feature" = "COMP ID"))

### 3. Vérification rapide ---------------------------------------------------
glimpse(met_stats)

```

```{r}
seuil_log2fc <- log(1.5)            # 0.5849625

filtered <- met_stats %>% 
  filter(
    pval <= 0.05,
    abs(logFC) >= seuil_log2fc,
    !is.na(InChIKey),                # gardes uniquement ceux qui ont une clé
    InChIKey != ""                   # et qui n’est pas vide
  )

cat("Après filtres p + logFC + InChIKey : ", nrow(filtered), " métabolites\n")

# Export – un InChIKey par ligne
writeLines(filtered$InChIKey, "aller_la_hihi.txt")
```

### On y est presque (proteo)

```{r}

oid_map <- medata_OlinkID %>%
  filter(OlinkID == "Uniprot ID") %>%
  pivot_longer(-OlinkID, names_to = "oid", values_to = "uniprot") %>%
  filter(uniprot != "")

prot_stats <- prot_stats %>%
      left_join(oid_map, by = c("feature" = "oid")) %>%
      mutate(feature = coalesce(uniprot, feature)) %>%
      select(feature, logFC, pval) %>%
      mutate(feature = str_remove_all(feature, "\\s+")) %>%
      separate_rows(feature, sep = ",")


filtered_prot <- prot_stats %>% 
  filter(
    pval <= 0.05,
    abs(logFC) >= seuil_log2fc,                  # et qui n’est pas vide
  )

library(clusterProfiler)
library(org.Hs.eg.db)

# Préparer le vecteur d'intérêts
prot_interest <- filtered_prot$feature

# Effectuer l'analyse ORA
ora_results <- enrichGO(prot_interest, keyType="UNIPROT", OrgDb="org.Hs.eg.db", pvalueCutoff=0.05)

```

```{r}
dotplot(
  ora_results,
  showCategory = 10,         # nombre de termes à afficher
  title        = "Top GO BP terms"
)
```

### On y est presque (miRNA)

```{r}

mir_interest <- gene_stats$feature      # hsa-let-7a-1, etc.

## ------------------------------------------------------------------
## 2. Interroger multiMiR (cibles validées uniquement) --------------
## ------------------------------------------------------------------
qry <- get_multimir(
           mirna   = mir_interest,
           org     = "hsa",
           table   = "validated",   # mirecords, miRTarBase, TarBase
           summary = FALSE           # regroupe les 3 bases
       )
```

```{r}
mirna2gene <- qry@data %>% 
  filter(database == "mirtarbase") %>%
  select(mature_mirna_id, target_symbol) %>% 
  distinct()

## 2.  Joindre aux stats et « doubler » les lignes si plusieurs cibles existent
##     (left_join le fait automatiquement)
gene_stats_targets <- gene_stats %>% 
  left_join(mirna2gene,              # clé de jointure
            by = c("feature" = "mature_mirna_id")) %>% 
  ## 3.  Remplacer le nom de la feature par le gène cible
  mutate(feature = target_symbol) %>% 
  select(feature, logFC, pval)

## 4.  (facultatif) Supprimer les miRNA sans cible connue
gene_stats_targets <- gene_stats_targets %>% 
  filter(!is.na(feature))

## 5.  Résultat
print(gene_stats_targets)
```

```{r}
df_avg <- gene_stats_targets %>%      # table « miRNA->gène + stats »
  group_by(feature) %>%                # 1. un groupe par gène cible
  slice_min(order_by = pval,           # 2. on garde la plus petite p-value
            n         = 1,             #    une seule ligne
            with_ties = FALSE) %>%     #    (FALSE = pas d'ex-æquo)
  ungroup() 


seuil_log2fc <- log2(1.5)            # 0.5849625

filtered_gene <- df_avg %>% 
  filter(
    pval <= 0.05,
    abs(logFC) >= seuil_log2fc,
  )

gene_interest <- filtered_gene$feature
```

```{r}
# ORA sur Gene Ontology
ora_gene <- enrichGO(
  gene          = gene_interest,
  keyType       = "SYMBOL",
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pvalueCutoff  = 0.05,
  maxGSSize     = 500,   # rejette les termes contenant >500 gènes
)


ora_gene_clean <- simplify(
  x       = ora_gene,
  cutoff  = 0.7,          # seuil de similarité sémantique (0–1)
  by      = "p.adjust",   # conserve le terme le plus significatif
  measure = "Wang"        # même métrique que dans clusterProfiler
)

dotplot(
  ora_gene_clean,
  showCategory = 10,         # nombre de termes à afficher
  title        = "Top GO BP terms"
)
```

## 8.combinaison

```{r}
###############################################################################
# 0)  LIBRAIRIES --------------------------------------------------------------
###############################################################################
library(tidyverse)      # dplyr, purrr …
library(readxl)         # lire oui.xlsx
library(metap)          # sumz, sumlog, sump  <- dépendance
# (multiGSEA n'est pas requis : on recopie sa fonction ci-dessous)

###############################################################################
# 1)  EXTRAIRE LES TROIS TABLEAUX ---------------------------------------------
###############################################################################
prot_df <- ora_results@result %>%                # protéines
  as_tibble() %>%
  transmute(go_id = ID,
            description = Description,
            prot_pval   = if ("pvalue"  %in% names(.)) pvalue  else p.adjust)

gene_df <- ora_gene_clean@result %>%                 # gènes
  as_tibble() %>%
  transmute(go_id = ID,
            description = Description,
            gene_pval   = if ("pvalue"  %in% names(.)) pvalue  else p.adjust)

met_df  <- read_xlsx("oui.xlsx") %>%             # métabolites
  transmute(go_id = GO_ID,
            description = GO_DESCRIPTION,
            met_pval    = PVALUE_ADJ_FDR)        # mettez 'pvalue' si dispo

###############################################################################
# 2)  FUSION SUR go_id --------------------------------------------------------
###############################################################################
merged <- list(gene_df, prot_df, met_df) %>%
  reduce(full_join, by = "go_id") %>%
  mutate(description = coalesce(description.x, description.y, description)) %>%
  select(go_id, description, ends_with("_pval"))

###############################################################################
# 3)  FONCTION combinePvalues  (copie multiGSEA, 2024-12-17) ------------------
###############################################################################
combinePvalues <- function(df,
                           method      = "stouffer",
                           col_pattern = "pval",
                           weights     = NULL) {

  method <- tolower(method)
  if (!method %in% c("stouffer", "fisher", "edgington"))
    stop("method must be 'stouffer', 'fisher' or 'edgington'")

  if (!col_pattern %in% c("pval", "padj"))
    stop("col_pattern must be 'pval' or 'padj'")

  cols <- grep(col_pattern, colnames(df))

  apply(df[, cols], 1, function(row) {

    row <- row[!is.na(row)]                 # enlève NA

    if (length(row) >= 2) {

      if (method == "fisher")      return(sumlog(row)$p)
      if (method == "edgington")   return(sump  (row)$p)

      ## ---------- Stouffer --------------------------------------------------
      row <- row[row > 0 & row < 1]         # sumz() exige 0<p<1
      if (length(row) >= 2) {
        if (!is.null(weights) && length(weights) > 0) {
          w <- weights[names(row)]          # *** filtrage clé ***
          return(sumz(row, weights = w)$p)
        }
        return(sumz(row)$p)
      }
    }

    if (length(row) == 1)  return(row[1])   # une seule couche
    NA_real_
  })
}


###############################################################################
# 4)  (OPTION)  POIDS pour Stoufer pondéré ------------------------------------
###############################################################################
weights <- c(gene_pval = 1, prot_pval = 1, met_pval = 1)   # √n par ex.

###############################################################################
# 5)  CALCUL DES p-VALUES COMBINÉES ------------------------------------------
###############################################################################
merged <- merged %>%
  mutate(
    p_comb_stoufer    = combinePvalues(., method = "stouffer")
  )

###############################################################################
# 6)  AJUSTEMENT BH -----------------------------------------------------------
###############################################################################
merged <- merged %>%
  mutate(across(starts_with("p_comb_"),
                ~ p.adjust(.x, method = "BH"),
                .names = "{.col}_adj"))

###############################################################################
# 7)  TOP 10 (Stoufer BH) -----------------------------------------------------
###############################################################################
merged %>%
  arrange(p_comb_stoufer_adj) %>%
  slice_head(n = 10) %>%
  print(n = 10)


yes <- merged %>%
  filter(p_comb_stoufer_adj<=0.05)



```

```{r}
library(dplyr)
library(clusterProfiler)   # apporte la classe enrichResult
# ── ton tableau d'origine ────────────────────────────────────────────────
res_df <- yes |>
  transmute(
    ID          = go_id,
    Description = description,
    pvalue      = p_comb_stoufer,
    p.adjust    = p_comb_stoufer_adj,
    qvalue      = p_comb_stoufer_adj,
    geneID      = "",          # placeholder
    Count       = 1L,          # ≥1 sinon treeplot proteste
    GeneRatio   = "0/0",
    BgRatio     = "0/0"
  ) |>
  as.data.frame() 


as_enrichResult <- function(df, ont = "BP") {
  slots <- methods::slotNames("enrichResult")
  proto <- list(Class   = "enrichResult",
                result  = df,
                geneSets= setNames(vector("list", nrow(df)), df$ID))
  opt <- list(ontology = ont, pvalueCutoff = 1, pAdjustMethod = "none",
              qvalueCutoff = 1, organism = "unknown", keytype = "UNKNOWN",
              readable = FALSE)
  for(nm in names(opt)) if (nm %in% slots) proto[[nm]] <- opt[[nm]]
  do.call(new, proto)
}

er <- as_enrichResult(res_df)   # ← objet identique à celui d’enrichGO

library(GOSemSim)
library(org.Hs.eg.db)

semBP <- godata("org.Hs.eg.db", ont = "BP", computeIC = FALSE)
er2   <- pairwise_termsim(er, method = "Wang", semData = semBP)


p <- treeplot(
        er2,
        showCategory   = 30,                    # 30 termes les + significatifs
        cluster.params = list(method = "average")
     )

###############################################################################
# 2A) Export facile avec ggsave  ---------------------------------------------
ggplot2::ggsave(
  filename = "treeplot_large.pdf",
  plot     = p,
  width    = 16.5,      # pouces  (≈ 42 cm)
  height   = 11.7,      # pouces  (≈ 29,7 cm)
  units    = "in",      # ou "cm"
  dpi      = 300        # n’affecte pas le PDF, mais utile si tu génères du PNG
)

p
```

##9. Enrichissement par module + diablo pour GO

### Combisaison des deux resultats

```{r}
library(readr)
library(dplyr)
library(ggVennDiagram)
library(ggplot2)

module_disease_analysis <- function(couleur, maladie) {
  
  # 1. Fichier de la maladie
  maladie_file  <- paste0("../results/mixOmics_", maladie, "_binary.csv")
  maladie_data  <- read_csv(maladie_file, show_col_types = FALSE)
  compounds_list <- maladie_data$compounds
  
  # 2. Variables du module de couleur donnée
  filtered_module <- moduleMembershipDF %>% 
    filter(ModuleColor == couleur)
  variables_list  <- rownames(filtered_module)
  
  # 3. Diagramme de Venn ─────────────────────────────────────────────
  venn_plot <- ggVennDiagram(
      list(DIABLO = compounds_list,
           Module = variables_list),
      label = "count"
    ) +
    theme_void() +
    ## désactive la découpe des éléments hors panneau
    coord_equal(clip = "off") +
    ## marge : 1 cm en haut, droite et bas ; 2 cm à gauche
    theme(plot.margin = unit(c(1, 1, 1, 2), "cm"))
  
  print(venn_plot)
  
  # 4. Fusion / filtrage des variables multi-omiques
  merged_list         <- union(compounds_list, variables_list)
  filtered_multiomics <- multi_omics[, intersect(colnames(multi_omics), merged_list)]
  
  invisible(filtered_multiomics)
}

# Exemple d’appel
resultat <- module_disease_analysis("yellow", "cca")

```

### Séparation des variables

```{r}
### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(resultat), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(resultat), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(resultat), value = TRUE)


print(length(gene_cols))
print(length(prot_cols))
print(length(met_cols))
```

### Enrichissement

```{r}


id2inchikey <- medata_metabolites %>% 
  mutate(`COMP ID` = as.character(`COMP ID`)) %>%   # COMP ID devient <chr>
  select(`COMP ID`, InChIKey) %>% 
  distinct()

################metabo################

# Assure-toi que met_cols est bien un vecteur de caractères (comme COMP ID)
met_cols <- as.character(met_cols)

# Filtrage
metabo_inchikey <- id2inchikey %>%
  filter(`COMP ID` %in% met_cols,
         !is.na(InChIKey),                # gardes uniquement ceux qui ont une clé
         InChIKey != "")


writeLines(metabo_inchikey$InChIKey, "test5.txt")






################protein################

proteine_uniprot <- oid_map %>%
  filter(`oid` %in% prot_cols)

# Préparer le vecteur d'intérêts
prot_interest <- proteine_uniprot$uniprot

# Effectuer l'analyse ORA
ora_prot <- enrichGO(prot_interest, keyType="UNIPROT", OrgDb="org.Hs.eg.db", pvalueCutoff=0.05, pAdjustMethod = "BH", maxGSSize = 500)





################miRNA################

mirna_symbol <- mirna2gene %>%
  filter(`mature_mirna_id` %in% gene_cols)

gene_interest <- mirna_symbol$target_symbol |>               # extrait la colonne
                 na.omit()            |>                      # retire les NA éventuels
                 unique()                                     # enlève les doublons


# ORA sur Gene Ontology
ora_gene <- enrichGO(
  gene          = gene_interest,
  keyType       = "SYMBOL",
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  maxGSSize = 500
)




```


### Fusion des pavlues

```{r}
###############################################################################
# 0)  LIBRAIRIES --------------------------------------------------------------
###############################################################################
library(tidyverse)      # dplyr, purrr …
library(readxl)         # lire oui.xlsx
library(metap)   
# sumz, sumlog, sump  <- dépendance
# (multiGSEA n'est pas requis : on recopie sa fonction ci-dessous)

###############################################################################
# 1)  EXTRAIRE LES TROIS TABLEAUX ---------------------------------------------
###############################################################################
prot_df <- ora_prot@result %>%                # protéines
  as_tibble() %>%
  transmute(go_id = ID,
            description = Description,
            prot_pval   =  p.adjust)

gene_df <- ora_gene@result %>%                 # gènes
  as_tibble() %>%
  transmute(go_id = ID,
            description = Description,
            gene_pval   = p.adjust)

met_df  <- read_xlsx("yes.xlsx") %>%             # métabolites
  transmute(go_id = GO_ID,
            description = GO_DESCRIPTION,
            met_pval    = PVALUE_ADJ_FDR)        # mettez 'pvalue' si dispo

###############################################################################
# 2)  FUSION SUR go_id --------------------------------------------------------
###############################################################################
merged1 <- list(gene_df, prot_df, met_df) %>%
  reduce(full_join, by = "go_id") %>%
  mutate(description = coalesce(description.x, description.y, description)) %>%
  select(go_id, description, ends_with("_pval"))

###############################################################################
# 3)  FONCTION combinePvalues  (copie multiGSEA, 2024-12-17) ------------------
###############################################################################
combinePvalues <- function(df,
                           method      = "stouffer",
                           col_pattern = "pval",
                           weights     = NULL) {

  method <- tolower(method)
  if (!method %in% c("stouffer", "fisher", "edgington"))
    stop("method must be 'stouffer', 'fisher' or 'edgington'")

  if (!col_pattern %in% c("pval", "padj"))
    stop("col_pattern must be 'pval' or 'padj'")

  cols <- grep(col_pattern, colnames(df))

  apply(df[, cols], 1, function(row) {

    row <- row[!is.na(row)]                 # enlève NA

    if (length(row) >= 2) {

      if (method == "fisher")      return(sumlog(row)$p)
      if (method == "edgington")   return(sump  (row)$p)

      ## ---------- Stouffer --------------------------------------------------
      row <- row[row > 0 & row < 1]         # sumz() exige 0<p<1
      if (length(row) >= 2) {
        if (!is.null(weights) && length(weights) > 0) {
          w <- weights[names(row)]          # *** filtrage clé ***
          return(sumz(row, weights = w)$p)
        }
        return(sumz(row)$p)
      }
    }

    if (length(row) == 1)  return(row[1])   # une seule couche
    NA_real_
  })
}


###############################################################################
# 4)  (OPTION)  POIDS pour Stoufer pondéré ------------------------------------
###############################################################################
weights <- c(gene_pval = 1, prot_pval = 1, met_pval = 1)   

###############################################################################
# 5)  CALCUL DES p-VALUES COMBINÉES ------------------------------------------
###############################################################################
merged <- merged1 %>%
  mutate(
    p_comb_stoufer    = combinePvalues(., method = "stouffer")
  )

###############################################################################
# 6)  AJUSTEMENT BH -----------------------------------------------------------
###############################################################################
merged <- merged %>%
  mutate(across(starts_with("p_comb_"),
                ~ p.adjust(.x, method = "BH"),
                .names = "{.col}_adj"))

###############################################################################
# 7)  TOP 10 (Stoufer BH) -----------------------------------------------------
###############################################################################

yes <- merged %>%
  filter(p_comb_stoufer_adj<=0.05)



```

### Treeplot


```{r}
library(dplyr)
library(clusterProfiler)   # apporte la classe enrichResult
library(GOSemSim)
library(org.Hs.eg.db)
library(enrichplot)
# ── ton tableau d'origine ────────────────────────────────────────────────
res_df <- yes |>
  transmute(
    ID          = go_id,
    Description = description,
    pvalue      = p_comb_stoufer,
    p.adjust    = p_comb_stoufer_adj,
    qvalue      = p_comb_stoufer_adj,
    geneID      = "",          # placeholder
    Count       = 1L,          # ≥1 sinon treeplot proteste
    GeneRatio   = "0/0",
    BgRatio     = "0/0"
  ) |>
  as.data.frame() 


as_enrichResult <- function(df, ont = "BP") {
  slots <- methods::slotNames("enrichResult")
  proto <- list(Class   = "enrichResult",
                result  = df,
                geneSets= setNames(vector("list", nrow(df)), df$ID))
  opt <- list(ontology = ont, pvalueCutoff = 1, pAdjustMethod = "none",
              qvalueCutoff = 1, organism = "unknown", keytype = "UNKNOWN",
              readable = FALSE)
  for(nm in names(opt)) if (nm %in% slots) proto[[nm]] <- opt[[nm]]
  do.call(new, proto)
}

er <- as_enrichResult(res_df)   


semBP <- godata("org.Hs.eg.db", ont = "BP", computeIC = FALSE)
er2   <- pairwise_termsim(er, method = "Wang", semData = semBP)

n     <- min(nrow(er@result), nrow(er2@termsim))  # plus de dépassement
treeplot(
  er2,
  showCategory   = 30,                          # exactly 30 categories
  cluster.params = list(method = "average")     # agglomération “average”
)


p <- treeplot(
        er2,
        showCategory   = 30,                    # 30 termes les + significatifs
        cluster.params = list(method = "average")
     )

###############################################################################
# 2A) Export facile avec ggsave  ---------------------------------------------
ggplot2::ggsave(
  filename = "treeplot_GO.pdf",
  plot     = p,
  width    = 16.5,      # pouces  (≈ 42 cm)
  height   = 11.7,      # pouces  (≈ 29,7 cm)
  units    = "in",      # ou "cm"
  dpi      = 300        # n’affecte pas le PDF, mais utile si tu génères du PNG
)

```



## 10. Enrichissement par module + diablo pour REACTOME

### Combisaison des deux resultats
```{r}
library(readr)
library(dplyr)
library(ggVennDiagram)
library(ggplot2)

module_disease_analysis <- function(couleur, maladie) {
  
  # Étape 1 : fichier de la maladie
  maladie_file <- paste0("../results/mixOmics_", maladie, "_binary.csv")
  maladie_data <- read_csv(maladie_file, show_col_types = FALSE)
  compounds_list <- maladie_data$compounds
  
  # Étape 2 : variables du module couleur
  filtered_module <- moduleMembershipDF %>%
    filter(ModuleColor == couleur)
  variables_list <- rownames(filtered_module)
  
  # 3. Diagramme de Venn  ────────────────────────────────────────────────
  venn_plot <- ggVennDiagram(
    list(Compounds = compounds_list,
         Variables = variables_list),
    label = "count"
  ) +
    theme_void()
  
  print(venn_plot)
  
  # Étape 4 : fusion des listes puis filtrage
  merged_list <- union(compounds_list, variables_list)
  filtered_multiomics <- multi_omics[, intersect(colnames(multi_omics), merged_list)]
  
  return(filtered_multiomics)
}

# Exemple d’appel :
resultat <- module_disease_analysis("yellow", "cca")
```

### Séparation des variables

```{r}
### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(resultat), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(resultat), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(resultat), value = TRUE)


print(length(gene_cols))
print(length(prot_cols))
print(length(met_cols))
```
### Calcul des fold change pour ces termes la

```{r}
library(limma)
calc_diff_limma <- function(mat, group_fac) {
  # mat : échantillons × variables  (donc on transp. plus bas)
  design <- model.matrix(~ group_fac)        # 0 = non-CCA, 1 = CCA
  fit    <- lmFit(t(mat), design)            # chaque métabolite = un modèle linéaire
  fit    <- eBayes(fit)                      # shrinkage des variances
  tibble(
    feature = rownames(fit$coefficients),
    logFC   = fit$coefficients[, "group_facCCA"],
    pval    = fit$p.value    [, "group_facCCA"]
  )
}


group_vec <- ifelse(metadata$cca_binary == 1, "CCA", "nonCCA")
group_fac <- factor(group_vec, levels = c("nonCCA", "CCA"))


### Statistiques brutes
gene_stats  <- calc_diff_limma(multi_omics[, gene_cols ],  group_fac)
prot_stats  <- calc_diff_limma(multi_omics[, prot_cols ],  group_fac)
met_stats   <- calc_diff_limma(multi_omics[, met_cols ],   group_fac)
```

### Mapping
```{r}

aggregate_duplicates <- function(df) {
  df %>% 
    mutate(weight = -log10(pval)) %>% 
    group_by(feature) %>% 
    summarise(
      logFC = weighted.mean(logFC, weight, na.rm = TRUE),
      pval  = combine_stouffer_w(pval, weight),
      .groups = "drop"
    ) %>% 
    mutate(padj = p.adjust(pval, method = "BH"))
}


## petit utilitaire : renvoie toujours une unique p-value numérique
combine_stouffer_w <- function(p, w) {
  ok <- !is.na(p) & !is.na(w)
  if (sum(ok) <= 1) return(p[ok][1])   # 0-1 p-value → inchangée
  metap::sumz(p[ok], weights = w[ok])$p
}



####Protéine######
prot_stats <- prot_stats %>%
      left_join(oid_map, by = c("feature" = "oid")) %>%
      mutate(feature = coalesce(uniprot, feature)) %>%
      select(feature, logFC, pval) %>%
      mutate(feature = str_remove_all(feature, "\\s+")) %>%
      separate_rows(feature, sep = ",")

prot_stats <- aggregate_duplicates(prot_stats)
####Metabolites######

met_map <- medata_metabolites %>%
  select(`COMP ID`, HMDB, KEGG) %>%
  mutate(cid_char = as.character(`COMP ID`),
         id_final = if_else(HMDB != "" & !is.na(HMDB), HMDB, KEGG)) %>%
  filter(id_final != "") %>%
  select(cid_char, id_final)

met_stats <- met_stats %>%
  left_join(met_map, by = c("feature" = "cid_char")) %>%
  mutate(feature = coalesce(id_final, feature),
         feature = str_remove_all(feature, "\\s+")) %>%
  separate_rows(feature, sep = ",") %>%
  select(feature, logFC, pval)

met_stats  <- aggregate_duplicates(met_stats)

####miRNA######
gene_stats_map <- gene_stats %>%
  inner_join(mirna2gene, by = c("feature" = "mature_mirna_id"))



gene_stats <- gene_stats_map %>%          # résultat de l'inner_join
  mutate(weight = -log10(pval)) %>%            # poids communs
  group_by(target_symbol) %>%                  # agrégation par gène
  summarise(
    n_miRNA   = n(),
    logFC_gene = weighted.mean(-logFC, weight, na.rm = TRUE),  # signe inversé !!
    pval_stf  = combine_stouffer_w(pval, weight),              # Stouffer pondéré
    .groups   = "drop"
  ) %>%
  mutate(
    padj_stf  = p.adjust(pval_stf, method = "BH"),         # score pour ranking
  )

gene_stats <- gene_stats %>%
  select(
    feature = target_symbol,
    logFC = logFC_gene,
    pval = padj_stf
  )

gene_stats = gene_stats %>% filter(if_all(everything(), ~ .x != "" & !is.na(.x)))

```



### Mise au format


```{r}
omics_data <- initOmicsDataStructure(
  layer = c("transcriptome", "proteome", "metabolome")
)

# transcriptome -------------------------------------------------------------
omics_data$transcriptome <- rankFeatures(gene_stats$logFC, gene_stats$pval)
names(omics_data$transcriptome) <- gene_stats$feature   

# proteome ------------------------------------------------------------------
omics_data$proteome <- rankFeatures(prot_stats$logFC, prot_stats$pval)
names(omics_data$proteome) <- prot_stats$feature        # <- noms UNIQUES

# metabolome ----------------------------------------------------------------
omics_data$metabolome <- rankFeatures(met_stats$logFC, met_stats$pval)
names(omics_data$metabolome) <- met_stats$feature
# --------------------------------------------------------------------------
# 3. Vérification finale : tout doit afficher 0
# --------------------------------------------------------------------------
lapply(omics_data, function(x) sum(duplicated(names(x))))
```


### Enrichissement

```{r}

databases <- c("reactome")  
layers    <- names(omics_data)

pathways <- getMultiOmicsFeatures(
  dbs               = databases,
  layer             = layers,
  returnTranscriptome = "SYMBOL",   # même type que vos noms de gènes
  returnProteome      = "UNIPROT",
  returnMetabolome    = "HMDB",
  useLocal            = FALSE       # TRUE si vous avez déjà un cache local
)

```

### Fusion des pvalues

```{r}
enrichment_scores <- multiGSEA(pathways, omics_data)

df_reactome <- extractPvalues(
  enrichmentScores = enrichment_scores,
  pathwayNames     = names(pathways[[1]])
)
```
```{r}
df_reactome <- cbind(data.frame(pathway = names(pathways[[1]])), df_reactome)
```



```{r}
###############################################################################
# 0)  LIBRAIRIES --------------------------------------------------------------
###############################################################################
library(tidyverse)
library(reactome.db)
library(multiGSEA)
library(clusterProfiler)
library(enrichplot)
library(ggplot2)

###############################################################################
# 1)  MAPPING Reactome : (REACTOME) -> R-HSA-xxxxx ----------------------------
###############################################################################
df_reactome <- df_reactome %>%
  mutate(Pathway_clean = gsub("^\\(REACTOME\\)\\s*", "", pathway))

path_map   <- as.list(reactomePATHNAME2ID)
human_map  <- path_map[grepl("^R-HSA-", unlist(path_map))]

get_reactome_id <- function(raw_label, clean_name) {
  if (!grepl("^\\(REACTOME\\)", raw_label)) return(NA_character_)
  if (clean_name %in% names(human_map))      return(human_map[[clean_name]])
  match <- agrep(clean_name, names(human_map), value = TRUE, max.distance = 0.2)
  if (length(match)) return(human_map[[match[1]]])
  NA_character_
}

df_reactome$Reactome_ID <- mapply(get_reactome_id,
                                  df_reactome$pathway,
                                  df_reactome$Pathway_clean)

###############################################################################
# 2)  COMBINAISON p-values (multiGSEA) ----------------------------------------
###############################################################################
df_reactome$combined_pval <- multiGSEA::combinePvalues(df_reactome)
df_reactome$combined_padj <- p.adjust(df_reactome$combined_pval, "BH")
```


```{r}
###############################################################################
# 3)  TABLE res_df pour enrichResult  – ID UNIQUE! ----------------------------
###############################################################################
res_df <- df_reactome %>%
  filter(!is.na(Reactome_ID), combined_padj <= 0.05) %>%
  transmute(
    raw_ID      = trimws(Reactome_ID),          # l’ID Reactome d’origine
    Description = Pathway_clean,
    pvalue      = combined_pval,
    p.adjust    = combined_padj,
    qvalue      = combined_padj,
    Count       = 1000L,
    GeneRatio   = "1/1000",
    BgRatio     = "10/20000"
  ) %>%
  ## --- rendre l’ID unique (ajoute .1, .2… si doublon) -----------------------
  mutate(ID = make.unique(raw_ID, sep = ".")) %>%
  select(-raw_ID) %>%
  as.data.frame()

###############################################################################
# 4)  AJOUT geneID ------------------------------------------------------------
###############################################################################
get_entities <- function(desc, defs) {
  key <- paste0("(REACTOME) ", desc)
  ents <- unique(c(defs$transcriptome[[key]],
                   defs$proteome[[key]],
                   defs$metabolome[[key]]))
  if (length(ents) == 0) NA_character_ else paste(ents, collapse = "/")
}

res_df$geneID <- vapply(res_df$Description, get_entities,
                        FUN.VALUE = character(1), defs = pathways)
res_df <- res_df[!is.na(res_df$geneID), ]

```


```{r}
library(enrichplot)
library(ggplot2)
################################################################################
# 1)  enrichResult + geneSets --------------------------------------------------
###############################################################################
er <- new("enrichResult",
          result        = res_df,
          geneSets      = setNames(strsplit(res_df$geneID, "/", fixed = TRUE),
                                   res_df$ID),
          pvalueCutoff  = 1,
          pAdjustMethod = "none",
          qvalueCutoff  = 1,
          organism      = "UNKNOWN",
          keytype       = "UNKNOWN",
          readable      = FALSE)

## compte, ratio ---------------------------------------------------------------
er@result$Count      <- lengths(er@geneSets)
er@result$GeneRatio  <- paste0(er@result$Count, "/", er@result$Count)
er@result$BgRatio    <- er@result$GeneRatio

###############################################################################
# 2)  matrice Jaccard ----------------------------------------------------------
###############################################################################
ids <- names(er@geneSets); n <- length(ids)
jac <- matrix(0, n, n, dimnames = list(ids, ids))
for(i in seq_len(n))
  for(j in i:n){
    inter <- length(intersect(er@geneSets[[i]], er@geneSets[[j]]))
    union <- length(unique(c(er@geneSets[[i]], er@geneSets[[j]])))
    jac[i,j] <- jac[j,i] <- ifelse(union==0, 0, inter/union)
  }
attr(er, "termsim") <- jac

###############################################################################
# 3)  Remplacer ID par la Description partout ---------------------------------
###############################################################################
lab_vec <- setNames(er@result$Description, er@result$ID)   # ID → libellé

## 3a. tableau result
er@result$ID <- lab_vec[er@result$ID]

## 3b. geneSets – conserver les noms identiques aux IDs renommés
names(er@geneSets) <- er@result$ID

## 3c. matrice de similarité : lignes & colonnes renommées
rownames(jac) <- colnames(jac) <- names(er@geneSets)
attr(er, "termsim") <- jac     # on remet la matrice renommée

###############################################################################
# 4)  TREEPLOT ----------------------------------------------------------------
###############################################################################
p <- treeplot(
        er,
        showCategory   = min(25, nrow(er@result)),
        cluster.params = list(method = "average"),
        label_format   = 60            # coupe >60 caractères
     )

ggsave("treeplot_reactome_manual.pdf",
       p, width = 16.5, height = 11.7, units = "in")
```


##11. Enrichissement par module + diablo pour KEGG

### Combisaison des deux resultats

```{r}
library(readr)
library(dplyr)
library(ggVennDiagram)
library(ggplot2)

module_disease_analysis <- function(couleur, maladie) {
  
  # Étape 1 : fichier de la maladie
  maladie_file <- paste0("../results/mixOmics_", maladie, "_binary.csv")
  maladie_data <- read_csv(maladie_file, show_col_types = FALSE)
  compounds_list <- maladie_data$compounds
  
  # Étape 2 : variables du module couleur
  filtered_module <- moduleMembershipDF %>%
    filter(ModuleColor == couleur)
  variables_list <- rownames(filtered_module)
  
  # 3. Diagramme de Venn  ────────────────────────────────────────────────
  venn_plot <- ggVennDiagram(
    list(Compounds = compounds_list,
         Variables = variables_list),
    label = "count"
  ) +
    theme_void()
  
  print(venn_plot)
  
  # Étape 4 : fusion des listes puis filtrage
  merged_list <- union(compounds_list, variables_list)
  filtered_multiomics <- multi_omics[, intersect(colnames(multi_omics), merged_list)]
  
  return(filtered_multiomics)
}

# Exemple d’appel :
resultat <- module_disease_analysis("yellow", "cca")
```

### Séparation des variables

```{r}
### Sélection de colonnes
gene_cols  <- grep("^hsa[-_]",  colnames(resultat), value = TRUE, ignore.case = TRUE)
prot_cols  <- grep("^OID",     colnames(resultat), value = TRUE)
met_cols   <- grep("^(X)?[0-9]+$", colnames(resultat), value = TRUE)


print(length(gene_cols))
print(length(prot_cols))
print(length(met_cols))
```

### Enrichissement

```{r}
library(clusterProfiler)
library(dplyr); library(stringr); library(tibble)
library(multiMiR); library(graphite); library(multiGSEA)
  library(dplyr); library(stringr); library(purrr)
  library(ggplot2); library(scico)

library(readr);  library(dplyr); library(purrr);  library(tidyr)
library(clusterProfiler); library(enrichplot);    library(ggplot2)
library(metap);  library(org.Hs.eg.db);           library(ggVennDiagram)

kegg_vec <- medata_metabolites %>% 
  filter(as.character(`COMP ID`) %in% met_cols) %>%          # étape 1-2
  filter(!is.na(KEGG), !KEGG %in% c("NA", "undefined")) %>%  # étape 3
  pull(KEGG) %>%                                             # vecteur KEGG
  unique()  

kegg_split  <- strsplit(kegg_vec, ",")   # sépare chaque élément sur la virgule
kegg_flat   <- unlist(kegg_split)        # aplatit la liste en vecteur
kegg_clean  <- trimws(kegg_flat)         # enlève les espaces éventuels
kegg_unique <- unique(kegg_clean)        # retire les doublons



ora_kegg_cpd <- enrichKEGG(
  gene          = kegg_unique,   # vecteur de C-numbers KEGG (ex. "C00022")
  organism      = "cpd",          
  keyType       = "kegg",           # ou "compound" – c’est équivalent
  pvalueCutoff  = 0.05,
  pAdjustMethod = "BH",
  maxGSSize     = 500
)
```


```{r}
library(org.Hs.eg.db)

################metabo################







################protein################

proteine_uniprot <- oid_map %>%
  filter(`oid` %in% prot_cols)

# Préparer le vecteur d'intérêts
prot_interest <- proteine_uniprot$uniprot

# Effectuer l'analyse ORA
ora_kegg_prot <- enrichKEGG(
  gene           = prot_interest,  # ton vecteur d’accessions UniProt (ex. "P04637")
  organism       = "hsa",          # code KEGG pour Homo sapiens
  keyType        = "uniprot",      # ou "ncbi-proteinid" selon tes IDs
  pvalueCutoff   = 0.05,
  pAdjustMethod  = "BH"
)





################miRNA################

mirna_symbol <- mirna2gene %>%
  filter(`mature_mirna_id` %in% gene_cols)

gene_interest <- mirna_symbol$target_symbol |>               # extrait la colonne
                 na.omit()            |>                      # retire les NA éventuels
                 unique()                                     # enlève les doublons



eg <- bitr(
  gene_interest,          # votre vecteur de symboles
  fromType = "SYMBOL",
  toType   = "ENTREZID",
  OrgDb    = org.Hs.eg.db
)

# ORA sur Gene Ontology
ora_kegg_gene <- enrichKEGG(
  gene            = eg$ENTREZID,
  keyType         = "kegg",
  organism        = "hsa",
  pAdjustMethod   = "BH",
  pvalueCutoff    = 0.05,
  maxGSSize       = 500
)




```


### Fusion des pavlues

```{r}
library(dplyr)
library(purrr)
###############################################################################
# 0)  LIBRAIRIES --------------------------------------------------------------
###############################################################################
library(tidyverse)        # dplyr, purrr, tibble, …
library(readxl)           # si besoin d’un xlsx externe
library(metap)            # sumlog, sumz, sump
library(clusterProfiler)  # enrichResult, pairwise_termsim
library(enrichplot)       # treeplot
library(ggplot2)          # ggsave

###############################################################################
# 1)  TABLEAUX KEGG (p-values) ------------------------------------------------
###############################################################################
normalize_pathway <- function(id) sub("^(hsa|map)", "", id)

prot_df <- ora_kegg_prot@result %>% 
  as_tibble() %>% 
  transmute(path_num   = normalize_pathway(ID),
            description = Description,
            prot_padj   = p.adjust)

gene_df <- ora_kegg_gene@result %>% 
  as_tibble() %>% 
  transmute(path_num   = normalize_pathway(ID),
            description = Description,
            gene_padj   = p.adjust)

met_df  <- ora_kegg_cpd@result %>% 
  as_tibble() %>% 
  transmute(path_num   = normalize_pathway(ID),
            description = Description,
            met_padj    = p.adjust)      # ou PVALUE_ADJ_FDR

###############################################################################
# 2)  FUSION DES p-VALUES -----------------------------------------------------
###############################################################################
merged1 <- list(gene_df, prot_df, met_df) %>% 
  purrr::reduce(full_join, by = "path_num") %>% 
  dplyr::mutate(description = coalesce(description.x, description.y, description)) %>% 
  dplyr::select(path_num, description, ends_with("_padj"))

###############################################################################
# 3)  COMBINAISON DES p-VALUES (Stouffer) ------------------------------------
###############################################################################
combinePvalues <- function(df,
                           method      = "stouffer",
                           col_pattern = "_padj") {

  cols <- grep(col_pattern, colnames(df))

  apply(df[, cols], 1, function(row){
    row <- row[!is.na(row)]
    row[row == 0] <- .Machine$double.xmin
    if (length(row) >= 2) return(sumz(row)$p)  # Stouffer
    if (length(row) == 1) return(row)
    NA_real_
  })
}

merged_kegg <- merged1 %>% 
  mutate(p_comb_stouffer      = combinePvalues(cur_data()),
         p_comb_stouffer_adj  = p.adjust(p_comb_stouffer, method = "BH"))

sig <- merged_kegg %>% filter(p_comb_stouffer_adj <= 0.05)

###############################################################################
# 4)  GENESETS réels (gène / protéine / composé) -----------------------------
###############################################################################
split_slash <- function(x) ifelse(is.na(x) | x == "", character(0),
                                  strsplit(x, "/", fixed = TRUE))

## --- depuis les trois enrichissements ---------------------------------------
genesets_gene <- ora_kegg_gene@result %>% 
  as_tibble() %>% 
  transmute(path_num = normalize_pathway(ID),
            gs       = map(geneID, split_slash))

genesets_prot <- ora_kegg_prot@result %>% 
  as_tibble() %>% 
  transmute(path_num = normalize_pathway(ID),
            gs       = map(geneID, split_slash))

genesets_met  <- ora_kegg_cpd@result %>% 
  as_tibble() %>% 
  transmute(path_num = normalize_pathway(ID),
            gs       = map(geneID, split_slash))

## --- fusion et union ---------------------------------------------------------
genesets_all <- bind_rows(genesets_gene, genesets_prot, genesets_met) %>% 
  group_by(path_num) %>% 
  summarise(geneSets = list(unique(unlist(gs))),
            Count    = lengths(geneSets),
            .groups  = "drop")

###############################################################################
# 5)  Tableau enrichResult complet -------------------------------------------
###############################################################################
sig2 <- sig %>% left_join(genesets_all, by = "path_num")


```

### Treeplot


```{r}
###############################################################################
# 4)  CONVERSION EN enrichResult ----------------------------------------------
###############################################################################
res_df <- sig2 %>% 
  transmute(
    ID          = path_num,
    Description = description,
    pvalue      = p_comb_stouffer,
    p.adjust    = p_comb_stouffer_adj,
    qvalue      = p_comb_stouffer_adj,
    geneID      = map_chr(geneSets, paste, collapse = "/"),
    Count,
    GeneRatio   = paste0(Count, "/", Count),   # placeholders
    BgRatio     = GeneRatio
  ) %>% 
  as.data.frame()

er <- new("enrichResult",
          result        = res_df,
          geneSets      = setNames(sig2$geneSets, sig2$path_num),
          pvalueCutoff  = 1,
          pAdjustMethod = "none",
          qvalueCutoff  = 1,
          organism      = "UNKNOWN",
          keytype       = "UNKNOWN",
          readable      = FALSE)


```

```{r}
# 1)  RECONSTRUIRE les geneSets à partir de er@result -------------------------
###############################################################################
## er est l’objet enrichResult que vous avez déjà produit
gs_list <- setNames(
  lapply(er@result$geneID, function(s) {
    strsplit(s, "/", fixed = TRUE)[[1]] |> unique()
  }),
  er@result$ID
)

## on met à jour l’objet (utile si gs_list diffère des anciens geneSets)
er@geneSets <- gs_list
er@result$Count      <- lengths(gs_list)
er@result$GeneRatio  <- paste0(er@result$Count, "/", er@result$Count)
er@result$BgRatio    <- er@result$GeneRatio    # placeholder

###############################################################################
# 2)  MATRICE DE SIMILARITÉ Jaccard (manuelle) --------------------------------
###############################################################################
ids <- names(gs_list)
n   <- length(ids)

jac <- matrix(0, n, n, dimnames = list(ids, ids))

for (i in seq_len(n)) {
  gi <- gs_list[[i]]
  for (j in i:n) {
    gj <- gs_list[[j]]
    inter <- length(intersect(gi, gj))
    uni   <- length(unique(c(gi, gj)))
    val   <- ifelse(uni == 0, 0, inter / uni)
    jac[i, j] <- val
    jac[j, i] <- val
  }
}

## Injecter la matrice dans l’objet
attr(er, "termsim") <- jac          # enrichplot la détecte ici


###############################################################################
# 3bis)  REMPLACER les IDs par « ID: Description » pour l’affichage ----------
###############################################################################
## ── remplacement simple ──────────────────────────────────────────────────
lab_vec <- with(er@result,
                setNames(Description, ID))   # ← plus de "ID: "

## puis les trois lignes comme avant
rownames(jac) <- colnames(jac) <- lab_vec[rownames(jac)]
names(gs_list)      <- lab_vec[names(gs_list)]
er@result$ID        <- lab_vec[er@result$ID]
attr(er, "termsim") <- jac            # jac est renommée ici même  

###############################################################################
# 3)  TREEPLOT ---------------------------------------------------------------
###############################################################################
p <- treeplot(er,
              showCategory   = 30,
              cluster.params = list(method = "average"),
              label_format   = 60)          # coupe après 60 caractères

ggsave("treeplot_kegg_manual.pdf",
       p, width = 16.5, height = 11.7, units = "in")

```


```{r}
###############################################################################
# 0)  SÉLECTION & CLASSEMENT DES TERMES POUR LE TREEPLOT -----------------------
###############################################################################
sig2_ranked <- sig2 %>% 
  mutate(
    nOmics = (!is.na(gene_padj)) + (!is.na(prot_padj)) + (!is.na(met_padj))
  ) %>% 
  filter(p_comb_stouffer_adj < 0.05) %>%          # seuil global (FDR)
  arrange(desc(nOmics), p_comb_stouffer_adj)      # 3 → 2 → 1, puis FDR

top30_ids <- head(sig2_ranked$path_num, 40)       # on garde au plus 30

###############################################################################
# 4)  CONVERSION EN enrichResult ----------------------------------------------
###############################################################################
res_df <- sig2 %>%                                # on garde TOUT pour er
  transmute(
    ID          = path_num,
    Description = description,
    pvalue      = p_comb_stouffer,
    p.adjust    = p_comb_stouffer_adj,
    qvalue      = p_comb_stouffer_adj,
    geneID      = map_chr(geneSets, paste, collapse = "/"),
    Count,
    GeneRatio   = paste0(Count, "/", Count),       # placeholders
    BgRatio     = GeneRatio
  ) %>% 
  as.data.frame()

er <- new("enrichResult",
          result        = res_df,
          geneSets      = setNames(sig2$geneSets, sig2$path_num),
          pvalueCutoff  = 1,
          pAdjustMethod = "none",
          qvalueCutoff  = 1,
          organism      = "UNKNOWN",
          keytype       = "UNKNOWN",
          readable      = FALSE)

###############################################################################
# 1)  RECONSTRUIRE les geneSets à partir de er@result -------------------------
###############################################################################
gs_list <- setNames(
  lapply(er@result$geneID, function(s) strsplit(s, "/", fixed = TRUE)[[1]] |> unique()),
  er@result$ID
)

er@geneSets            <- gs_list
er@result$Count        <- lengths(gs_list)
er@result$GeneRatio    <- paste0(er@result$Count, "/", er@result$Count)
er@result$BgRatio      <- er@result$GeneRatio          # placeholder

###############################################################################
# 2)  MATRICE DE SIMILARITÉ Jaccard (manuelle) --------------------------------
###############################################################################
ids <- names(gs_list); n <- length(ids)
jac <- matrix(0, n, n, dimnames = list(ids, ids))
for (i in seq_len(n)) {
  gi <- gs_list[[i]]
  for (j in i:n) {
    gj <- gs_list[[j]]
    inter <- length(intersect(gi, gj))
    uni   <- length(unique(c(gi, gj)))
    val   <- ifelse(uni == 0, 0, inter / uni)
    jac[i, j] <- val; jac[j, i] <- val
  }
}
attr(er, "termsim") <- jac

###############################################################################
# 3bis)  REMPLACER les IDs par « Description » --------------------------------
###############################################################################
lab_vec <- with(er@result, setNames(Description, ID))
rownames(jac)        <- colnames(jac) <- lab_vec[rownames(jac)]
names(gs_list)       <- lab_vec[names(gs_list)]
er@result$ID         <- lab_vec[er@result$ID]
attr(er, "termsim")  <- jac           # jac est renommée ici même  

###############################################################################
# 3)  TREEPLOT ---------------------------------------------------------------
###############################################################################
## Correspondance path_num → libellé final
show_vec <- lab_vec[top30_ids] |> unname()

p <- treeplot(
  er,
  showCategory   = show_vec,            # on impose l’ordre et la sélection
  cluster.params = list(method = "average"),
  label_format   = 60                   # coupe après 60 caractères
)

ggsave("treeplot_kegg_manuals.pdf",
       p, width = 16.5, height = 11.7, units = "in")

```



```{r}
###############################################################################
## 0)  Préparatifs
###############################################################################
library(dplyr)        # filter(), pull()
library(tidyr)        # unnest() pour l’export CSV

min_prop <- 0.75      # seuil « représentatif » (≥ 75 % des termes du cluster)

###############################################################################
## 1)  Conteneurs de sortie
###############################################################################
representative_genes_by_cluster <- list()
unique_genes_by_term_by_cluster <- list()

###############################################################################
## 2)  Boucle sur les clusters présents (cluster_1 … cluster_5)
###############################################################################
cluster_ids <- p[["data"]] %>% 
  dplyr::filter(isTip, !is.na(group), grepl("^cluster_", group)) %>% 
  dplyr::pull(group) %>% 
  unique()

for (cl in cluster_ids) {
  
  ## 2-a)  Termes du cluster (labels non-NA)
  terms <- p[["data"]] %>% 
    dplyr::filter(isTip, group == cl, !is.na(label)) %>% 
    dplyr::pull(label) %>% 
    unique()
  
  if (length(terms) == 0) next                     # cluster vide → on saute
  
  ## 2-b)  Sous-ensemble de er@result pour ces termes
  rows <- er@result %>% dplyr::filter(ID %in% terms)
  
  ## 2-c)  Liste terme → vecteur de gènes
  genes_by_term <- setNames(
    lapply(rows$geneID, function(s) unique(strsplit(s, "/", fixed = TRUE)[[1]])),
    rows$ID
  )
  
  ## 2-d)  Gènes représentatifs
  freq <- table(unlist(genes_by_term))
  reps <- names(freq)[ freq / length(genes_by_term) >= min_prop ]
  representative_genes_by_cluster[[cl]] <- sort(reps)
  
  ## 2-e)  Gènes spécifiques à chaque terme
  uniq_list <- lapply(names(genes_by_term), function(term) {
    setdiff(genes_by_term[[term]],
            unlist(genes_by_term[names(genes_by_term) != term]))
  })
  names(uniq_list) <- names(genes_by_term)
  unique_genes_by_term_by_cluster[[cl]] <- uniq_list
}





```

```{r}
library(readr)

# séparateur virgule (standard CSV international)
write_csv(sig2, "mon_fichier.csv")  
```


### 12. Fonction KEGG

```{r}
###############################################################################
# 0)  FONCTION UTILITAIRE : modules + maladie  → filtered_multiomics + Venn   #
###############################################################################
multi_module_disease_analysis <- function(modules, maladie, show_venn = TRUE) {

  # --- 1. Compounds de la maladie -------------------------------------------
  maladie_file   <- paste0("../results/mixOmics_", maladie, "_binary.csv")
  compounds_list <- readr::read_csv(maladie_file, show_col_types = FALSE)$compounds

  # --- 2. Variables de tous les modules -------------------------------------
  variables_list_union <- moduleMembershipDF |>
    dplyr::filter(ModuleColor %in% modules) |>
    rownames()

  # --- 3. Diagramme de Venn unique ------------------------------------------
  if (show_venn) {
    ven <- ggVennDiagram::ggVennDiagram(
             list(Compounds = compounds_list,
                  Variables = variables_list_union),
             label = "count") +
           ggplot2::theme_void()
    print(ven)
  }

  # --- 4. Jeu multi-omics filtré --------------------------------------------
  merged_list         <- union(compounds_list, variables_list_union)
  filtered_multiomics <- multi_omics[, intersect(colnames(multi_omics), merged_list)]

  return(filtered_multiomics)
}

###############################################################################
#  FONCTION PRINCIPALE : multi_module_kegg_pipeline                           #
###############################################################################
# • modules  : vecteur de couleurs WGCNA   ex. c("yellow", "blue")
# • maladie  : code maladie                ex. "cca"
# • p_cutoff : seuil FDR                    (déf. 0.05)
# • out_pdf  : nom du fichier treeplot      (déf. "treeplot_kegg_manual.pdf")
# • verbose  : TRUE → messages + Venn
###############################################################################
multi_module_kegg_pipeline <- function(modules,
                                       maladie,
                                       p_cutoff = 0.05,
                                       out_pdf  = "treeplot_kegg_manual.pdf",
                                       verbose  = TRUE) {

  ## 0)  LIBRAIRIES -----------------------------------------------------------
  suppressPackageStartupMessages({
    library(readr);  library(dplyr); library(purrr);  library(tidyr)
    library(clusterProfiler); library(enrichplot);    library(ggplot2)
    library(metap);  library(org.Hs.eg.db);           library(ggVennDiagram)
  })

  ## 1)  JEU MULTI-OMICS UNIQUE ----------------------------------------------
  if (verbose) message("➜ Étape 1 : construction du jeu multi-omics…")
  multi_omics_mod <- multi_module_disease_analysis(modules, maladie,
                                                   show_venn = verbose)

  ## 2)  SÉPARATION DES VARIABLES --------------------------------------------
  if (verbose) message("➜ Étape 2 : séparation des gènes / prot / métabo…")
  gene_cols <- grep("^hsa[-_]",  colnames(multi_omics_mod), value = TRUE,
                    ignore.case = TRUE)
  prot_cols <- grep("^OID",      colnames(multi_omics_mod), value = TRUE)
  met_cols  <- grep("^(X)?[0-9]+$", colnames(multi_omics_mod), value = TRUE)

  ## 3)  ENRICHISSEMENTS KEGG -------------------------------------------------
  if (verbose) message("➜ Étape 3 : enrichissements KEGG…")

  # 3a) Métabolites
  kegg_unique <- medata_metabolites %>%
    filter(as.character(`COMP ID`) %in% met_cols,
           !is.na(KEGG), !KEGG %in% c("NA", "undefined")) %>%
    pull(KEGG) |> strsplit(",") |> unlist() |> trimws() |> unique()

  ora_kegg_cpd <- enrichKEGG(gene = kegg_unique, organism = "cpd",
                             keyType = "kegg", pvalueCutoff = 1,
                             pAdjustMethod = "BH", maxGSSize = 500)

  # 3b) Protéines
  prot_interest <- oid_map %>%
    filter(oid %in% prot_cols) %>% pull(uniprot) %>% unique()

  ora_kegg_prot <- enrichKEGG(gene = prot_interest, organism = "hsa",
                              keyType = "uniprot", pvalueCutoff = 1,
                              pAdjustMethod = "BH")

  # 3c) miRNA → gènes cibles
  gene_interest <- mirna2gene %>%
    filter(mature_mirna_id %in% gene_cols) %>%
    pull(target_symbol) %>% na.omit() %>% unique()

  eg <- bitr(gene_interest, fromType = "SYMBOL", toType = "ENTREZID",
             OrgDb = org.Hs.eg.db)

  ora_kegg_gene <- enrichKEGG(gene = eg$ENTREZID, organism = "hsa",
                              keyType = "kegg", pvalueCutoff = 1,
                              pAdjustMethod = "BH", maxGSSize = 500)

  ## 4)  MÉTA-ANALYSE DES p-VALUES -------------------------------------------
  if (verbose) message("➜ Étape 4 : fusion & méta-analyse des p-values…")

  normalize_pathway <- function(id) sub("^(hsa|map)", "", id)
  tidy_enrich <- function(er, colname) er@result %>%
    as_tibble() %>%
    transmute(path_num   = normalize_pathway(ID),
              description = Description,
              !!colname   := p.adjust)

  prot_df <- tidy_enrich(ora_kegg_prot, "prot_padj")
  gene_df <- tidy_enrich(ora_kegg_gene, "gene_padj")
  met_df  <- tidy_enrich(ora_kegg_cpd,  "met_padj")

  merged_kegg <- list(gene_df, prot_df, met_df) %>%
    reduce(full_join, by = "path_num") %>%
    mutate(description = coalesce(description.x, description.y, description)) %>%
    select(path_num, description, ends_with("_padj")) %>%
    mutate(
      p_comb_stouffer = apply(across(ends_with("_padj")), 1, \(row){
        vals <- row[!is.na(row)]
        vals[vals == 0] <- .Machine$double.xmin
        if (length(vals) >= 2) return(sumz(vals)$p)
        if (length(vals) == 1) return(vals)
        NA_real_
      }),
      p_comb_stouffer_adj = p.adjust(p_comb_stouffer, method = "BH")
    )

  sig <- merged_kegg %>% filter(p_comb_stouffer_adj <= p_cutoff)

  ## 5)  TREEPLOT -------------------------------------------------------------
  if (verbose) message("➜ Étape 5 : génération du treeplot…")

  # 5a) Préparation des geneSets
  split_slash <- \(x) ifelse(is.na(x) | x == "", character(0),
                             strsplit(x, "/", fixed = TRUE))
  gset <- function(er) er@result %>%
    as_tibble() %>% transmute(path_num = normalize_pathway(ID),
                              gs = map(geneID, split_slash))

  genesets_all <- bind_rows(gset(ora_kegg_gene),
                            gset(ora_kegg_prot),
                            gset(ora_kegg_cpd)) %>%
    group_by(path_num) %>%
    summarise(geneSets = list(unique(unlist(gs))),
              Count    = lengths(geneSets),
              .groups  = "drop")

  sig2 <- sig %>% left_join(genesets_all, by = "path_num")

  # 5b) Objet enrichResult
  res_df <- sig2 %>% transmute(
    ID          = path_num,
    Description = description,
    pvalue      = p_comb_stouffer,
    p.adjust    = p_comb_stouffer_adj,
    qvalue      = p_comb_stouffer_adj,
    geneID      = map_chr(geneSets, paste, collapse = "/"),
    Count,
    GeneRatio   = paste0(Count, "/", Count),
    BgRatio     = GeneRatio
  ) %>% as.data.frame()

  er <- new("enrichResult",
            result        = res_df,
            geneSets      = setNames(sig2$geneSets, sig2$path_num),
            pvalueCutoff  = 1, pAdjustMethod = "none",
            qvalueCutoff  = 1, organism = "UNKNOWN",
            keytype = "UNKNOWN", readable = FALSE)

  # 5c) Similarité Jaccard + renommage
  gs_list <- setNames(
    map(er@result$geneID,
        \(s) strsplit(s, "/", fixed = TRUE)[[1]] |> unique()),
    er@result$ID)

  ids <- names(gs_list); n <- length(ids)
  jac <- matrix(0, n, n, dimnames = list(ids, ids))
  for (i in seq_len(n)) {
    gi <- gs_list[[i]]
    for (j in i:n) {
      gj            <- gs_list[[j]]
      jac[i, j]     <- jac[j, i] <-
        ifelse(length(unique(c(gi, gj))) == 0, 0,
               length(intersect(gi, gj)) / length(unique(c(gi, gj))))
    }
  }

  lab_vec <- with(er@result, setNames(Description, ID))
  rownames(jac)  <- colnames(jac)  <- lab_vec[rownames(jac)]
  names(gs_list) <- lab_vec[names(gs_list)]
  er@result$ID   <- lab_vec[er@result$ID]

  attr(er, "termsim") <- jac
  er@geneSets        <- gs_list

  # 5d) Treeplot
  p <- treeplot(er,
                showCategory   = min(30, nrow(er@result)),
                cluster.params = list(method = "average"),
                label_format   = 60)
  ggsave(out_pdf, p, width = 16.5, height = 11.7, units = "in")

  if (verbose) message("✓ Terminé !  Treeplot sauvegardé dans « ", out_pdf, " ».")

  ## 6)  VALEUR DE RETOUR -----------------------------------------------------
  invisible(list(
    filtered_multiomics = multi_omics_mod,
    ora_kegg_gene       = ora_kegg_gene,
    ora_kegg_prot       = ora_kegg_prot,
    ora_kegg_cpd        = ora_kegg_cpd,
    merged_kegg         = merged_kegg,
    sig_paths           = sig2,
    enrichResult        = er,
    treeplot            = p
  ))
}

```

```{r}
res <- multi_module_kegg_pipeline(
         modules = c("brown","green"),
         maladie = "fibrosis",
         p_cutoff = 0.05,
         out_pdf  = "treeplot_multimod_fibrosis.pdf"
       )

```

